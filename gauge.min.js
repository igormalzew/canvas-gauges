/*!
 * The MIT License (MIT)
 * 
 * Copyright (c) 2016 Mykhailo Stadnyk <mikhus@gmail.com>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * @version 2.1.5
 */
(function(ns) {/**
 * @external {Object.assign} https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */
/* istanbul ignore next */
if (!Object.assign) {
    Object.defineProperty(Object, 'assign', {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function(target, firstSource) {
            'use strict';

            if (target === undefined || target === null) {
                throw new TypeError('Cannot convert first argument to object');
            }

            var to = Object(target);
            var i = 1;

            for (; i < arguments.length; i++) {
                var nextSource = arguments[i];

                if (nextSource === undefined || nextSource === null) {
                    continue;
                }

                var keysArray = Object.keys(Object(nextSource));
                var nextIndex = 0, len = keysArray.length;

                for (; nextIndex < len; nextIndex++) {
                    var nextKey = keysArray[nextIndex];
                    var desc = Object.getOwnPropertyDescriptor(
                        nextSource, nextKey);

                    if (desc !== undefined && desc.enumerable) {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }

            return to;
        }
    });
}

/**
 * @external {Array.indexOf} https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
 */
/* istanbul ignore next */
if (!Array.prototype.indexOf) {
    Object.defineProperty(Array.prototype, "indexOf", {
		value: function(searchElement, fromIndex) {
			var k;

			if (this === null) {
				throw new TypeError('"this" is null or not defined');
			}

			var O = Object(this);
			var len = O.length >>> 0;

			if (len === 0) {
				return -1;
			}

			var n = +fromIndex || 0;

			if (Math.abs(n) === Infinity) {
				n = 0;
			}

			if (n >= len) {
				return -1;
			}

			k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

			while (k < len) {
				if (k in O && O[k] === searchElement) {
					return k;
				}

				k++;
			}

			return -1;
		}
	});
}

/**
 * @external {Array.fill} https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/fill
 */
/* istanbul ignore next */
if (!Array.prototype.fill) {
    Object.defineProperty(Array.prototype, "fill", {
		value: function(value) {
			if (this === null) {
				throw new TypeError('this is null or not defined');
			}

			var O = Object(this);
			var len = O.length >>> 0;
			var start = arguments[1];
			var relativeStart = start >> 0;
			var k = relativeStart < 0 ?
				Math.max(len + relativeStart, 0) :
				Math.min(relativeStart, len);
			var end = arguments[2];
			var relativeEnd = end === undefined ?
				len : end >> 0;
			var final = relativeEnd < 0 ?
				Math.max(len + relativeEnd, 0) :
				Math.min(relativeEnd, len);
			while (k < final) {
				O[k] = value;
				k++;
			}

			return O;
		}
	});
    
}

/**
 * mocking window
 */
if (typeof window === 'undefined') {
    window = typeof global === 'undefined' ? {} : global;
}

/*!
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Mykhailo Stadnyk <mikhus@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/**
 * Look-ups for a proper vendor-specific property and returns its value
 *
 * @example
 * var requestAnimationFrame = vendorize('requestAnimationFrame');
 * // it will refer properly to:
 * //  - window.requestAnimationFrame by default or to
 * //  - window.webkitRequestAnimationFrame or to
 * //  - window.mozRequestAnimationFrame or to
 * //  - window.msRequestAnimationFrame or to
 * //  - window.oRequestAnimationFrame
 * // depending on the current browser vendor
 *
 * @author Mykhailo Stadnyk <mikhus@gmail.com>
 * @param {string} prop
 * @param {HTMLElement|Window|object} [from] - default is window
 * @returns {*}
 */
function vendorize(prop, from) {
    /* istanbul ignore else: no reason to cover */
    if (!from) {
        from = typeof window === 'undefined' ? global : window;
    }

    if (typeof from[prop] !== 'undefined') {
        return from[prop];
    }

    let vendors = ['webkit', 'moz', 'ms', 'o'];
    let i = 0;
    let s = vendors.length;
    let capitalized = prop.charAt(0).toUpperCase() + prop.substr(1);

    for (; i < s; i++) {
        let vendorProp = from[vendors[i] + capitalized];

        /* istanbul ignore if: requires very complex environment to test (specific browser version) */
        if (typeof vendorProp !== 'undefined') {
            return vendorProp;
        }
    }

    return null;
}


/*!
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Mykhailo Stadnyk <mikhus@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * Class EventEmitter - base event manager
 */
class EventEmitter {
    /**
     * @constructor
     */
    constructor() {
        this._events = {};

        this.addListener = this.on;
        this.removeListener = this.off;
    }

    /**
     * Returns all event listeners
     *
     * @return {object}
     */
    get listeners() {
        return this._events;
    }

    /**
     * Emits given event bypassing to each registered handler given args
     *
     * @param {string} event
     * @param {...*} args
     */
    emit(event, ...args) {
        if (this._events[event]) {
            let i = 0;
            let s = this._events[event].length;

            for (; i < s; i++) {
                this._events[event][i] &&
                this._events[event][i].apply(this, args);
            }
        }
    }

    /**
     * Registers given handler for given event to be called only once when
     * event is emitted
     *
     * @param {string} event
     * @param {...function} handlers
     */
    once(event, ...handlers) {
        let i = 0;
        let s = handlers.length;
        let self = this;

        for (; i < s; i++) {
            let handler = handlers[i];
            let wrapper = function() {
                self.off(event, wrapper);
                handler.apply(self, arguments);
            };

            handlers[i] = wrapper;
        }

        this.on.apply(this, [event].concat(handlers));
    }

    /**
     * Registers given handlers for a given events to be called each time event
     * is emitted
     *
     * @param {string} event
     * @param {...function} handlers
     */
    on(event, ...handlers) {
        if (!this._events[event]) {
            this._events[event] = [];
        }

        let i = 0;
        let s = handlers.length;

        for (; i < s; i++) {
            this._events[event].push(handlers[i]);
        }
    }

    /**
     * Un-registers previously registered event handlers
     *
     * @param {string} event
     * @param {...function} handlers
     */
    off(event, ...handlers) {
        if (!this._events[event]) {
            return ;
        }

        let i = 0;
        let s = handlers.length;

        for (; i < s; i++) {
            let handler = handlers[i];
            let index;

            while (~(index = this._events[event].indexOf(handler))) {
                this._events[event].splice(index, 1);
            }
        }
    }

    /**
     * Removes all listeners for a given event
     *
     * @param {string} event
     */
    removeAllListeners(event) {
        delete this._events[event];
    }
}


/*!
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Mykhailo Stadnyk <mikhus@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/* jshint -W079 */


/**
 * @ignore
 * @typedef {object} ns
 */

/* istanbul ignore next */
/**
 * @type {function(callback: function(time: number): number, element?: HTMLElement)}
 * @access private
 */
const requestAnimationFrame = vendorize('requestAnimationFrame') ||
    (callback => setTimeout(() => callback(new Date().getTime()), 1000 / 60));

/**
 * Generic AnimationRule function interface
 *
 * @typedef {function(percent: number): number} AnimationRule
 */

/**
 * Callback for animation step draw event.
 * It will be called each time animation step is executed, bypassing
 * as first argument a percent of animation completeness. It is expected
 * that this callback will do an actual work of animating an elements or
 * whatever, as far as animation engine is just calculating and executing
 * animation steps without any knowledge about things under animation.
 *
 * @typedef {function(percent: number): *} DrawEventCallback
 */

/**
 * Callback for animation complete event.
 * It is called once each animation is complete.
 *
 * @typedef {function(): *} EndEventCallback
 */

/**
 * Predefined known animation rules.
 * It's a simple collection of math for some most used animations.
 *
 * @typedef {{linear: AnimationRule, quad: AnimationRule, dequad: AnimationRule, quint: AnimationRule, dequint: AnimationRule, cycle: AnimationRule, decycle: AnimationRule, bounce: AnimationRule, debounce: AnimationRule, elastic: AnimationRule, delastic: AnimationRule}} AnimationRules
 */

/* istanbul ignore next: no reason covering this */
let rules = {
    linear: p => p,
    quad: p => Math.pow(p, 2),
    dequad: p => 1 - rules.quad(1 - p),
    quint: p => Math.pow(p, 5),
    dequint: p => 1 - Math.pow(1 - p, 5),
    cycle: p => 1 - Math.sin(Math.acos(p)),
    decycle: p => Math.sin(Math.acos(1 - p)),
    bounce: p => 1 - rules.debounce(1 - p),
    debounce: p => {
        let a = 0, b = 1;
        for (; 1; a += b, b /= 2) {
            if (p >= (7 - 4 * a) / 11) {
                return -Math.pow((11 - 6 * a - 11 * p) / 4, 2) +
                    Math.pow(b, 2);
            }
        }
    },
    elastic: p => 1 - rules.delastic(1 - p),
    delastic: p => {
        let x = 1.5;
        return Math.pow(2, 10 * (p - 1)) *
            Math.cos(20 * Math.PI * x / 3 * p);
    }
};

/* istanbul ignore next: private, not testable */
/**
 * Evaluates animation step and decides if the next step required or
 * stops animation calling a proper events.
 *
 * @access private
 * @param {number} time
 * @param {DrawEventCallback} draw
 * @param {number} start
 * @param {AnimationRule} rule
 * @param {number} duration
 * @param {EndEventCallback} end
 * @param {Animation} anim
 */
function step(time, draw, start, rule, duration, end, anim) {
    if (typeof rule !== 'function') {
        throw new TypeError('Invalid animation rule:', rule);
    }

    let progress = time - start;
    let percent = progress / duration;
    let animationTransformed = 0;

    if (percent > 1) {
        percent = 1;
    }

    if (percent !== 1) {
        animationTransformed = rule(percent);

        // make sure we have correct number after applying animation
        // transformation
        if (isFinite(animationTransformed) && !isNaN(animationTransformed)) {
            percent = animationTransformed;
        }
    }

    draw && draw(percent);

    if (progress < duration) {
        anim.frame = requestAnimationFrame(time =>
            step(time, draw, start, rule, duration, end, anim)
        );
    }

    else {
        end && end();
        anim.inProgress = false;
    }
}

/**
 * Animation engine API for JavaScript-based animations.
 * This is simply an animation core framework which simplifies creation
 * of various animations for generic purposes.
 *
 * @example
 * // create 'linear' animation engine, 500ms duration
 * let linear = new Animation('linear', 500);
 *
 * // create 'elastic' animation engine
 * let elastic = new Animation('elastic');
 *
 * // define animation behavior
 * let bounced = new Animation('bounce', 500, percent => {
 *     let value = parseInt(percent * 100, 10);
 *
 *     $('div.bounced').css({
 *         width: value + '%',
 *         height: value + '%'
 *     });
 * });
 *
 * // execute animation
 * bounced.animate();
 *
 * // execute animation and handle when its finished
 * bounced.animate(null, () => {
 *    console.log('Animation finished!');
 * });
 */
class Animation {

    /**
     * @constructor
     * @param {string|AnimationRule} rule
     * @param {number} duration
     * @param {DrawEventCallback} [draw]
     * @param {EndEventCallback} [end]
     */
    constructor(rule = 'linear', duration = 250, draw = (()=>{}),
                end = (()=>{}))
    {
        /**
         * Overall animation duration in milliseconds.
         * By default is equal to 250 ms.
         *
         * @type {number}
         */
        this.duration = duration;

        /**
         * Animation rule. By default is linear animation.
         * Animation rule is a subject to animation rules, which are
         * a simple object containing math-based methods for calculating
         * animation steps.
         *
         * @type {string|AnimationRule}
         */
        this.rule = rule;

        /**
         * Callback function for the animation step draw event.
         *
         * @type {DrawEventCallback}
         */
        this.draw = draw;

        /**
         * Callback for the animation complete event.
         *
         * @type {EndEventCallback}
         */
        this.end = end;

        if (typeof this.draw !== 'function') {
            throw new TypeError('Invalid animation draw callback:', draw);
        }

        if (typeof this.end !== 'function') {
            throw new TypeError('Invalid animation end callback:', end);
        }
    }

    /* istanbul ignore next: non-testable */
    /**
     * Performs animation calling each animation step draw callback and
     * end callback at the end of animation. Callbacks are optional to this
     * method call. If them are not bypassed will be used that ones which
     * was pre-set on constructing an Animation object or pre-set after
     * construction.
     *
     * @example
     * function draw(percent) {
     *     $('.my-animated-divs').css({
     *         width: parseInt(percent * 100, 10) + '%'
     *     });
     * }
     * function done() {
     *     console.log('Animation complete!');
     * }
     *
     * // Define 'draw' and 'end' callbacks on construction
     * var animation = new Animation('cycle', 500, draw, done);
     * animation.animate();
     *
     * // Define 'draw' and 'end' callbacks after construction
     * var animation = new Animation('cycle', 500);
     * animation.draw = draw;
     * animation.end = done;
     * animation.animate();
     *
     * // Define 'draw' and 'end' callbacks at animation
     * var animation = new Animation('cycle', 500);
     * animation.animate(draw, done);
     *
     * @param {DrawEventCallback} [draw]
     * @param {EndEventCallback} [end]
     */
    animate(draw, end) {
        this.frame && this.cancel();

        // noinspection JSUnresolvedVariable
        const start = window.performance && window.performance.now ?
                window.performance.now() :
                (vendorize('animationStartTime') || Date.now());

        draw = draw || this.draw;
        end = end || this.end;

        this.draw = draw;
        this.end = end;

        /**
         * Current requested animation frame identifier
         *
         * @type {number}
         */
        this.frame = requestAnimationFrame(time =>
            step(time, draw, start, rules[this.rule] || this.rule,
                this.duration, end, this));
    }

    /**
     * Cancels current animation if any
     */
    cancel() {
        if (this.frame) {
            const cancelAnimationFrame = vendorize('cancelAnimationFrame') ||
                /* istanbul ignore next */
                ((id) => {});

            cancelAnimationFrame(this.frame);
            this.frame = null;
        }
    }

    /**
     * Destroys this object properly
     */
    destroy() {
        this.cancel();
        this.draw = null;
        this.end = null;
    }
}

/**
 * Animation rules bound statically to Animation constructor.
 *
 * @type {AnimationRules}
 * @static
 */
Animation.rules = rules;


/*!
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Mykhailo Stadnyk <mikhus@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/**
 * @typedef {{ constructor: function(options: GenericOptions): GaugeInterface, draw: function(): GaugeInterface, destroy: function, update: function(options: GenericOptions) }} GaugeInterface
 */
/**
 * @typedef {{parse: function, stringify: function}} JSON
 * @external {JSON} https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/JSON
 */
/**
 * @ignore
 * @typedef {{MutationObserver: function}} ns
 */

/**
 * DOM Observer.
 * It will observe DOM document for a configured element types and
 * instantiate associated Types for an existing or newly added DOM elements
 *
 * @example
 * class ProgressBar {
 *     constructor(options) {}
 *     draw() {}
 * }
 *
 * // It will observe DOM document for elements <div>
 * // having attribute 'data-type="progress"'
 * // and instantiate for each new instance of ProgressBar
 *
 * new DomParser({color: 'red'}, 'div', 'progress', ProgressBar);
 *
 * // assume we could have HTML like this
 * // <div data-type="progress" color="blue"></div>
 * // in this case all matching attributes names for a given options will be
 * // parsed and bypassed to an instance from HTML attributes
 */
class DomObserver {

    /**
     * @constructor
     * @param {object} options
     * @param {string} element
     * @param {string} type
     */
    constructor(options, element, type) {
        //noinspection JSUnresolvedVariable
        /**
         * Default instantiation options for the given type
         *
         * @type {Object}
         */
        this.options = options;

        /**
         * Name of an element to lookup/observe
         *
         * @type {string}
         */
        this.element = element.toLowerCase();

        /**
         * data-type attribute value to lookup
         *
         * @type {string}
         */
        this.type = DomObserver.toDashed(type);

        /**
         * Actual type constructor to instantiate for each found element
         *
         * @type {Function}
         */
        this.Type = ns[type];

        /**
         * Signals if mutations observer for this type or not
         *
         * @type {boolean}
         */
        this.mutationsObserved = false;

        /**
         * Flag specifies whenever the browser supports observing
         * of DOM tree mutations or not
         *
         * @type {boolean}
         */
        this.isObservable = !!window.MutationObserver;

        /* istanbul ignore next: this should be tested with end-to-end tests */
        if (!window.GAUGES_NO_AUTO_INIT) {
            DomObserver.domReady(this.traverse.bind(this));
        }
    }

    /**
     * Checks if given node is valid node to process
     *
     * @param {Node|HTMLElement} node
     * @returns {boolean}
     */
    isValidNode(node) {
        //noinspection JSUnresolvedVariable
        return !!(
            node.tagName &&
            node.tagName.toLowerCase() === this.element &&
            node.getAttribute('data-type') === this.type
        );
    }

    /**
     * Traverse entire current DOM tree and process matching nodes.
     * Usually it should be called only once on document initialization.
     */
    traverse() {
        let elements = document.getElementsByTagName(this.element);
        let i = 0, s = elements.length;

        /* istanbul ignore next: this should be tested with end-to-end tests */
        for (; i < s; i++) {
            this.process(elements[i]);
        }

        if (this.isObservable && !this.mutationsObserved) {
            new MutationObserver(this.observe.bind(this))
                .observe(document.body, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    characterData: true,
                    attributeOldValue: true,
                    characterDataOldValue: true
                });

            this.mutationsObserved = true;
        }
    }

    /**
     * Observes given mutation records for an elements to process
     *
     * @param {MutationRecord[]} records
     */
    observe(records) {
        let i = 0;
        let s = records.length;

        /* istanbul ignore next: this should be tested with end-to-end tests */
        for (; i < s; i++) {
            let record = records[i];

            if (record.type === 'attributes' &&
                record.attributeName === 'data-type' &&
                this.isValidNode(record.target) &&
                record.oldValue !== this.type) // skip false-positive mutations
            {
                setTimeout(this.process.bind(this, record.target));
            }

            else if (record.addedNodes && record.addedNodes.length) {
                let ii = 0;
                let ss = record.addedNodes.length;

                for (; ii < ss; ii++) {
                    setTimeout(this.process.bind(this, record.addedNodes[ii]));
                }
            }
        }
    }

    /**
     * Parses given attribute value to a proper JavaScript value.
     * For example it will parse some stringified value to a proper type
     * value, e.g. 'true' => true, 'null' => null, '{"prop": 20}' => {prop: 20}
     *
     * @param {*} value
     * @return {*}
     */
    static parse(value) {
        // parse boolean
        if (value === 'true') return true;
        if (value === 'false') return false;

        // parse undefined
        if (value === 'undefined') return undefined;

        // parse null
        if (value === 'null') return null;

        // Comma-separated strings to array parsing.
        // It won't match strings which contains non alphanumeric characters to
        // prevent strings like 'rgba(0,0,0,0)' or JSON-like from being parsed.
        // Typically it simply allows easily declare arrays as comma-separated
        // numbers or plain strings. If something more complicated is
        // required it can be declared using JSON format syntax
        if (/^[-+#.\w\d\s]+(?:,[-+#.\w\d\s]*)+$/.test(value)) {
            return value.split(',');
        }

        // parse JSON
        try { return JSON.parse(value); } catch(e) {}

        // plain value - no need to parse
        return value;
    }

    /**
     * Processes a given node, instantiating a proper type constructor for it
     *
     * @param {Node|HTMLElement} node
     * @returns {GaugeInterface|null}
     */
    process(node) {
        if (!this.isValidNode(node)) return null;

        let prop;
        let options = JSON.parse(JSON.stringify(this.options));
        let instance = null;

        for (prop in options) {
            /* istanbul ignore else: non-testable in most cases */
            if (options.hasOwnProperty(prop)) {
                let attributeName = DomObserver.toAttributeName(prop);
                let attributeValue = DomObserver.parse(
                    node.getAttribute(attributeName));

                if (attributeValue !== null && attributeValue !== undefined) {
                    options[prop] = attributeValue;
                }
            }
        }

        options.renderTo = node;
        instance = new (this.Type)(options);
        instance.draw && instance.draw();

        if (!this.isObservable) return instance;

        instance.observer = new MutationObserver(records => {
            records.forEach(record => {
                if (record.type === 'attributes') {
                    let attr = record.attributeName.toLowerCase();
                    let type = node.getAttribute(attr).toLowerCase();

                    if (attr === 'data-type' && type && type !== this.type) {
                        instance.observer.disconnect();
                        delete instance.observer;
                        instance.destroy && instance.destroy();
                    }

                    else if (attr.substr(0, 5) === 'data-') {
                        let prop = attr.substr(5).split('-').map((part, i) => {
                            return !i ? part :
                            part.charAt(0).toUpperCase() + part.substr(1);
                        }).join('');
                        let options = {};

                        options[prop] = DomObserver.parse(
                            node.getAttribute(record.attributeName));


                        if (prop === 'value') {
                            instance && (instance.value = options[prop]);
                        }

                        else {
                            instance.update && instance.update(options);
                        }
                    }
                }
            });
        });

        //noinspection JSCheckFunctionSignatures
        instance.observer.observe(node, { attributes: true });

        return instance;
    }

    /**
     * Transforms camelCase string to dashed string
     *
     * @static
     * @param {string} camelCase
     * @return {string}
     */
    static toDashed(camelCase) {
        let arr = camelCase.split(/(?=[A-Z])/);
        let i = 1;
        let s = arr.length;
        let str = arr[0].toLowerCase();

        for (; i < s; i++) {
            str += '-' + arr[i].toLowerCase();
        }

        return str;
    }

    /**
     * Transforms dashed string to CamelCase representation
     *
     * @param {string} dashed
     * @param {boolean} [capitalized]
     * @return {string}
     */
    static toCamelCase(dashed, capitalized = true) {
        let arr = dashed.split(/-/);
        let i = 0;
        let s = arr.length;
        let str = '';

        for (; i < s; i++) {
            if (!(i || capitalized)) {
                str += arr[i].toLowerCase();
            }

            else {
                str += arr[i][0].toUpperCase() + arr[i].substr(1).toLowerCase();
            }
        }

        return str;
    }

    /**
     * Transforms camel case property name to dash separated attribute name
     *
     * @static
     * @param {string} str
     * @returns {string}
     */
    static toAttributeName(str) {
        return 'data-' + DomObserver.toDashed(str);
    }

    /**
     * Cross-browser DOM ready handler
     *
     * @static
     * @param {Function} handler
     */
    static domReady(handler) {
        if (/comp|inter|loaded/.test((window.document || {}).readyState + ''))
            return handler();

        if (window.addEventListener)
            window.addEventListener('DOMContentLoaded', handler, false);

        else if (window.attachEvent)
            window.attachEvent('onload', handler);
    }

}


/*!
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Mykhailo Stadnyk <mikhus@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * @ignore
 * @typedef {object} ns
 */

/**
 * Drawings on canvas using hidden canvas as a cache for better
 * performance drawings during canvas animations. SmartCanvas also
 * adopts a canvas to
 */
class SmartCanvas {

    /**
     * @constructor
     * @param {HTMLCanvasElement} canvas
     * @param {number} [width]
     * @param {number} [height]
     */
    constructor(canvas, width, height) {
        SmartCanvas.collection.push(this);

        /**
         * Canvas base width
         *
         * @type {number}
         */
        this.width = width || 0;

        /**
         * Canvas base height
         *
         * @type {number}
         */
        this.height = height || 0;

        /**
         * Target drawings canvas element
         *
         * @type {HTMLCanvasElement}
         */
        this.element = canvas;

        this.init();
    }

    /**
     * Initializes canvases and contexts
     */
    init() {
        let pixelRatio = SmartCanvas.pixelRatio;

        this.element.width = this.width * pixelRatio;
        this.element.height = this.height * pixelRatio;

        this.element.style.width = this.width + 'px';
        this.element.style.height = this.height + 'px';

        /**
         * Canvas caching element
         *
         * @type {HTMLCanvasElement|Node}
         */
        this.elementClone = this.element.cloneNode(true);

        //noinspection JSUnresolvedVariable
        /**
         * Target drawings canvas element 2D context
         *
         * @type {CanvasRenderingContext2D}
         */
        this.context = this.element.getContext('2d');

        /**
         * Canvas caching element 2D context
         *
         * @type {CanvasRenderingContext2D}
         */
        this.contextClone = this.elementClone.getContext('2d');

        /**
         * Actual drawings width
         *
         * @type {number}
         */
        this.drawWidth = this.element.width;

        /**
         * Actual drawings height
         *
         * @type {number}
         */
        this.drawHeight = this.element.height;

        /**
         * X-coordinate of drawings zero point
         *
         * @type {number}
         */
        this.drawX = this.drawWidth / 2;

        /**
         * Y-coordinate of drawings zero point
         *
         * @type {number}
         */
        this.drawY = this.drawHeight / 2;

        /**
         * Minimal side length in pixels of the drawing
         *
         * @type {number}
         */
        this.minSide = this.drawX < this.drawY ? this.drawX : this.drawY;

        this.elementClone.initialized = false;

        this.contextClone.translate(this.drawX, this.drawY);
        this.contextClone.save();

        this.context.translate(this.drawX, this.drawY);
        this.context.save();

        this.context.max = this.contextClone.max = this.minSide;
        this.context.maxRadius = this.contextClone.maxRadius = null;
    }

    /**
     * Destroys this object, removing the references from memory
     */
    destroy() {
        let index = SmartCanvas.collection.indexOf(this);

        /* istanbul ignore else */
        if (~index) {
            SmartCanvas.collection.splice(index, 1);
        }

        this.context.clearRect(
            -this.drawX,
            -this.drawY,
            this.drawWidth,
            this.drawHeight
        );

        // dereference all created elements
        this.context.max = null;
        delete this.context.max;

        this.context.maxRadius = null;
        delete this.context.maxRadius;

        this.context = null;
        this.contextClone = null;
        this.elementClone = null;
        this.element = null;

        /**
         * On canvas redraw event callback
         *
         * @type {function|null|undefined}
         */
        this.onRedraw = null;
    }

    /**
     * Commits the drawings
     */
    commit() {
        let scale = SmartCanvas.pixelRatio;

        if (scale !== 1) {
            this.contextClone.scale(scale, scale);
            this.contextClone.save();
        }

        return this;
    }

    /**
     * Redraw this object
     */
    redraw() {
        this.init();

        /**
         * On canvas redraw event callback
         *
         * @type {function(): *}
         */
        this.onRedraw && this.onRedraw();

        return this;
    }

    /**
     * Returns current device pixel ratio
     *
     * @returns {number}
     */
    static get pixelRatio() {
        /* istanbul ignore next */
        //noinspection JSUnresolvedVariable
        return window.devicePixelRatio || 1;
    }

    /**
     * Forces redraw all canvas in the current collection
     */
    static redraw() {
        let i = 0;
        let s = SmartCanvas.collection.length;

        for (; i < s; i++) {
            SmartCanvas.collection[i].redraw();
        }
    }
}

SmartCanvas.collection = [];

/* istanbul ignore next: very browser-specific testing required to cover */
//noinspection JSUnresolvedVariable
if (window.matchMedia) {
    //noinspection JSUnresolvedFunction
    window.matchMedia('screen and (min-resolution: 2dppx)')
        .addListener(SmartCanvas.redraw);
}


/*!
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Mykhailo Stadnyk <mikhus@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * Describes rendering target element. Can be either string identifier of
 * the element or the element itself.
 *
 * @typedef {HTMLElement|string} RenderTarget
 */

/**
 * Highlight area definition.
 * It describes highlight area starting from value to value using
 * color. Color can be describes with hex, rgb or rgba value.
 *
 * @typedef {{ from: number, to: number, color: string}} Highlight
 */

/**
 * Shared generic gauges options
 *
 * @type {{renderTo: RenderTarget, width: number, height: number, minValue: number, maxValue: number, value: number, units: string|boolean, majorTicks: number[]|string[], exactTicks: boolean, minorTicks: number, strokeTicks: boolean, animatedValue: boolean, animateOnInit: boolean, title: string|boolean, borders: boolean, valueInt: number, valueDec: number, majorTicksInt: number, majorTicksDec: number, animation: boolean, animationDuration: number, animationRule: string|AnimationRule, colorPlate: string, colorPlateEnd: string, colorMajorTicks: string, colorMinorTicks: string, colorStrokeTicks: string, colorTitle: string, colorUnits: string, colorNumbers: string, colorNeedle: string, colorNeedleEnd: string, colorValueText: string, colorValueTextShadow: string, colorBorderShadow: string, colorBorderOuter: string, colorBorderOuterEnd: string, colorBorderMiddle: string, colorBorderMiddleEnd: string, colorBorderInner: string, colorBorderInnerEnd: string, colorValueBoxRect: string, colorValueBoxRectEnd: string, colorValueBoxBackground: string, colorValueBoxShadow: string, colorNeedleShadowUp: string, colorNeedleShadowDown: string, needle: boolean, needleShadow: boolean, needleType: string, needleStart: number, needleEnd: number, needleWidth: number, borderOuterWidth: number, borderMiddleWidth: number, borderInnerWidth: number, borderShadowWidth: number, valueBox: boolean, valueBoxWidth: number, valueBoxStroke: number, valueText: string, valueTextShadow: boolean, valueBoxBorderRadius: number, highlights: Highlight[], highlightsWidth: number, fontNumbers: string, fontTitle: string, fontUnits: string, fontValue: string, fontTitleSize: number, fontValueSize: number, fontUnitsSize: number, fontNumbersSize: number, fontNumbersStyle: string, fontTitleStyle: string, fontUnitsStyle: string, fontValueStyle: string, fontNumbersWeight: string, fontTitleWeight: string, fontUnitsWeight: string, fontValueWeight: string, barWidth: number, barStrokeWidth: number, barProgress: boolean, colorBar: string, colorBarStroke: string, colorBarProgress: string, colorBarShadow: string, barShadow: number, listeners: object}} GenericOptions
 */
const GenericOptions = {
    // basic options
    renderTo: null,
    width: 0,
    height: 0,
    minValue: 0,
    maxValue: 100,
    value: 0,
    units: false,
    exactTicks: false,
    majorTicks: [0, 20, 40, 60, 80, 100],
    minorTicks: 10,
    strokeTicks: true,
    animatedValue: false,
    animateOnInit: false,
    title: false,
    borders: true,
    numbersMargin: 1,

    listeners: null,

    // number formats
    valueInt: 3,
    valueDec: 2,
    majorTicksInt: 1,
    majorTicksDec: 0,

    // animations
    animation: true,
    animationDuration: 500,
    animationRule: 'cycle',

    // colors
    colorPlate: '#fff',
    colorPlateEnd: '',
    colorMajorTicks: '#444',
    colorMinorTicks: '#666',
    colorStrokeTicks: '',
    colorTitle: '#888',
    colorUnits: '#888',
    colorNumbers: '#444',
    colorNeedle: 'rgba(240,128,128,1)',
    colorNeedleEnd: 'rgba(255,160,122,.9)',
    colorValueText: '#444',
    colorValueTextShadow: 'rgba(0,0,0,0.3)',
    colorBorderShadow: 'rgba(0,0,0,0.5)',
    colorBorderOuter: '#ddd',
    colorBorderOuterEnd: '#aaa',
    colorBorderMiddle: '#eee',
    colorBorderMiddleEnd: '#f0f0f0',
    colorBorderInner: '#fafafa',
    colorBorderInnerEnd: '#ccc',
    colorValueBoxRect: '#888',
    colorValueBoxRectEnd: '#666',
    colorValueBoxBackground: '#babab2',
    colorValueBoxShadow: 'rgba(0,0,0,1)',
    colorNeedleShadowUp: 'rgba(2,255,255,0.2)',
    colorNeedleShadowDown: 'rgba(188,143,143,0.45)',
    colorBarStroke: '#222',
    colorBar: '#ccc',
    colorBarProgress: '#888',
    colorBarShadow: '#000',

    fontNumbers: 'Arial',
    fontTitle: 'Arial',
    fontUnits: 'Arial',
    fontValue: 'Arial',

    fontNumbersSize: 20,
    fontTitleSize: 24,
    fontUnitsSize: 22,
    fontValueSize: 26,

    fontNumbersStyle: 'normal',
    fontTitleStyle: 'normal',
    fontUnitsStyle: 'normal',
    fontValueStyle: 'normal',

    fontNumbersWeight: 'normal',
    fontTitleWeight: 'normal',
    fontUnitsWeight: 'normal',
    fontValueWeight: 'normal',

    // needle
    needle: true,
    needleShadow: true,
    needleType: 'arrow',
    needleStart: 5,
    needleEnd: 85,
    needleWidth: 4,

    // borders
    borderOuterWidth: 3,
    borderMiddleWidth: 3,
    borderInnerWidth: 3,
    borderShadowWidth: 3,

    // value and highlights
    valueBox: true,
    valueBoxStroke: 5,
    valueBoxWidth: 0,
    valueText: '',
    valueTextShadow: true,
    valueBoxBorderRadius: 2.5,

    // highlights
    highlights: [
        { from: 20, to: 60, color: '#eee' },
        { from: 60, to: 80, color: '#ccc' },
        { from: 80, to: 100, color: '#999' }],
    highlightsWidth: 15,

    // progress bar
    barWidth: 20, // percents
    barStrokeWidth: 0, // pixels
    barProgress: true,
    barShadow: 0
};




/*!
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Mykhailo Stadnyk <mikhus@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * Gauge collections type.
 *
 * It is used ES5 declaration here, because babel
 * transpiles inheritance incorrectly in this case.
 *
 * @class Collection
 * @constructor
 */
function Collection () {
    Array.prototype.constructor.apply(this, arguments);
}

Collection.prototype = Object.create(Array.prototype);
Collection.prototype.constructor = Collection;

    /**
     * Returns gauge object by its identifier or index in the collection
     *
     * @param {string|number} id
     * @return {*}
     */
Collection.prototype.get = function(id) {
    if (typeof id === 'string') {
        let i = 0;
        let s = this.length;

        for (; i < s; i++) {
            let canvas = this[i].options.renderTo.tagName ?
                this[i].options.renderTo :
                /* istanbul ignore next: should be tested with e2e tests */
                document.getElementById(this[i].options.renderTo || '');

            if (canvas.getAttribute('id') === id) {
                return this[i];
            }
        }
    }

    else if (typeof id === 'number') {
        return this[id];
    }

    return null;
};


/*!
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Mykhailo Stadnyk <mikhus@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */








const version = '2.1.5';

const round = Math.round;
const abs = Math.abs;

let gauges = new Collection();

gauges.version = version;

/**
 * Basic abstract BaseGauge class implementing common functionality
 * for different type of gauges.
 *
 * It should not be instantiated directly but must be extended by a final
 * gauge implementation.
 *
 * @abstract
 * @example
 *
 * class MyCoolGauge extends BaseGauge {
 *
 *     // theses methods below MUST be implemented:
 *
 *     constructor(options) {
 *        // ... do something with options
 *        super(options);
 *        // ... implement anything else
 *     }
 *
 *     draw() {
 *         // ... some implementation here
 *         return this;
 *     }
 * }
 */
class BaseGauge extends EventEmitter {

    /**
     * Fired each time gauge is initialized on a page
     *
     * @event BaseGauge#init
     */

    /**
     * Fired each time gauge scene is rendered
     *
     * @event BaseGauge#render
     */

    /**
     * Fired each time gauge object is destroyed
     *
     * @event BaseGauge#destroy
     */

    /**
     * Fired each time before animation is started on the gauge
     *
     * @event BaseGauge#animationStart
     */

    /**
     * Fired each time animation scene is complete
     *
     * @event BaseGauge#animate
     * @type {number} percent
     * @type {number} value
     */

    /**
     * Fired each time animation is complete on the gauge
     *
     * @event BaseGauge#animationEnd
     */

    /**
     * @event BaseGauge#value
     * @type {number} newValue
     * @type {number} oldValue
     */

    /**
     * @constructor
     * @abstract
     * @param {GenericOptions} options
     */
    constructor(options) {
        super();

        let className = this.constructor.name;

        if (className === 'BaseGauge') {
            throw new TypeError('Attempt to instantiate abstract class!');
        }

        gauges.push(this);

        if (options.listeners) {
            Object.keys(options.listeners).forEach(event => {
                let handlers = options.listeners[event] instanceof Array ?
                    options.listeners[event] : [options.listeners[event]];

                handlers.forEach(handler => {
                    this.on(event, handler);
                });
            });
        }

        //noinspection JSUnresolvedVariable
        /**
         * Gauges version string
         *
         * @type {string}
         */
        this.version = version;

        /**
         * Gauge type class
         *
         * @type {BaseGauge} type
         */
        this.type = ns[className] || BaseGauge;

        /**
         * True if gauge has been drawn for the first time, false otherwise.
         *
         * @type {boolean}
         */
        this.initialized = false;

        options.minValue = parseFloat(options.minValue);
        options.maxValue = parseFloat(options.maxValue);
        options.value = parseFloat(options.value) || 0;

        if (!options.borders) {
            options.borderInnerWidth = options.borderMiddleWidth =
                options.borderOuterWidth = 0;
        }

        if (!options.renderTo) {
            throw TypeError('Canvas element was not specified when creating ' +
                'the Gauge object!');
        }

        let canvas = options.renderTo.tagName ?
            options.renderTo :
            /* istanbul ignore next: to be tested with e2e tests */
            document.getElementById(options.renderTo);

        if (!(canvas instanceof HTMLCanvasElement)) {
            throw TypeError('Given gauge canvas element is invalid!');
        }

        options.width = parseFloat(options.width) || 0;
        options.height = parseFloat(options.height) || 0;

        if (!options.width || !options.height) {
            if (!options.width) options.width = canvas.parentNode ?
                canvas.parentNode.offsetWidth : canvas.offsetWidth;
            if (!options.height) options.height = canvas.parentNode ?
                canvas.parentNode.offsetHeight : canvas.offsetHeight;
        }

        /**
         * Gauge options
         *
         * @type {GenericOptions} options
         */
        this.options = options || {};

        if (this.options.animateOnInit) {
            this._value = this.options.value;
            this.options.value = this.options.minValue;
        }

        /**
         * @type {SmartCanvas} canvas
         */
        this.canvas = new SmartCanvas(canvas, options.width, options.height);
        this.canvas.onRedraw = this.draw.bind(this);

        /**
         * @type {Animation} animation
         */
        this.animation = new Animation(
            options.animationRule,
            options.animationDuration);
    }

    /**
     * Sets new value for this gauge.
     * If gauge is animated by configuration it will trigger a proper animation.
     * Upsetting a value triggers gauge redraw.
     *
     * @param {number} value
     */
    set value(value) {
        value = BaseGauge.ensureValue(value, this.options.minValue);

        let fromValue = this.options.value;

        if (value === fromValue) {
            return ;
        }

        if (this.options.animation) {
            if (this.animation.frame) {
                // animation is already in progress -
                // forget related old animation value
                // @see https://github.com/Mikhus/canvas-gauges/issues/94
                this.options.value = this._value;

                // if there is no actual value change requested stop it
                if (this._value === value) {
                    this.animation.cancel();
                    delete this._value;
                    return ;
                }
            }

            /**
             * @type {number}
             * @access private
             */
            if (this._value === undefined) {
                this._value = value;
            }

            this.emit('animationStart');

            this.animation.animate(percent => {
                let newValue = fromValue + (value - fromValue) * percent;

                this.options.animatedValue &&
                    this.emit('value', newValue, this.value);

                this.options.value = newValue;

                this.draw();

                this.emit('animate', percent, this.options.value);
            }, () => {
                if (this._value !== undefined) {
                    this.emit('value', this._value, this.value);
                    this.options.value = this._value;
                    delete this._value;
                }

                this.draw();
                this.emit('animationEnd');
            });
        }

        else {
            this.emit('value', value, this.value);
            this.options.value = value;
            this.draw();
        }
    }

    /**
     * Returns current value of the gauge
     *
     * @return {number}
     */
    get value() {
        return typeof this._value === 'undefined' ?
            this.options.value : this._value;
    }

    /**
     * Updates gauge options
     *
     * @param {*} options
     * @return {BaseGauge}
     * @access protected
     */
    static configure(options) {
        return options;
    }

    /**
     * Updates gauge configuration options at runtime and redraws the gauge
     *
     * @param {RadialGaugeOptions} options
     * @returns {BaseGauge}
     */
    update(options) {
        Object.assign(this.options, this.type.configure(options || {}));

        this.canvas.width = this.options.width;
        this.canvas.height = this.options.height;

        this.animation.rule = this.options.animationRule;
        this.animation.duration = this.options.animationDuration;

        this.canvas.redraw();

        return this;
    }

    /**
     * Performs destruction of this object properly
     */
    destroy() {
        let index = gauges.indexOf(this);

        /* istanbul ignore else */
        if (~index) {
            //noinspection JSUnresolvedFunction
            gauges.splice(index, 1);
        }

        this.canvas.destroy();
        this.canvas = null;

        this.animation.destroy();
        this.animation = null;

        this.emit('destroy');
    }

    /**
     * Returns gauges version string
     *
     * @return {string}
     */
    static get version() {
        return version;
    }

    /**
     * Triggering gauge render on a canvas.
     *
     * @abstract
     * @returns {BaseGauge}
     */
    draw() {
        if (this.options.animateOnInit && !this.initialized) {
            this.value = this._value;
            this.initialized = true;
            this.emit('init');
        }

        this.emit('render');

        return this;
    }

    /**
     * Inject given gauge object into DOM
     *
     * @param {string} type
     * @param {GenericOptions} options
     */
    static initialize(type, options) {
        return new DomObserver(options, 'canvas', type);
    }

    /**
     * Initializes gauge from a given HTML element
     * (given element should be valid HTML canvas gauge definition)
     *
     * @param {HTMLElement} element
     */
    static fromElement(element) {
        let type = DomObserver.toCamelCase(element.getAttribute('data-type'));
        let attributes = element.attributes;
        let i = 0;
        let s = attributes.length;
        let options = {};

        if (!type) {
            return ;
        }

        if (!/Gauge$/.test(type)) {
            type += 'Gauge';
        }

        for (; i < s; i++) {
            options[
                DomObserver.toCamelCase(
                    attributes[i].name.replace(/^data-/, ''),
                    false)
            ] = DomObserver.parse(attributes[i].value);
        }

        new DomObserver(options, element.tagName, type).process(element);
    }

    /**
     * Ensures value is proper number
     *
     * @param {*} value
     * @param {number} min
     * @return {number}
     */
    static ensureValue(value, min = 0) {
        value = parseFloat(value);

        if (isNaN(value) || !isFinite(value)) {
            value = parseFloat(min) || 0;
        }

        return value;
    }

    /**
     * Corrects javascript modulus bug
     * @param {number} n
     * @param {number} m
     * @return {number}
     */
    static mod(n,m) {
        return ((n % m) + m) % m;
    }
}


/**
 * @ignore
 * @typedef {object} ns
 */
/* istanbul ignore if */
if (typeof ns !== 'undefined') {
    ns['BaseGauge'] = BaseGauge;
    ns['gauges'] = (window.document || {})['gauges'] = gauges;
}


/*!
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Mykhailo Stadnyk <mikhus@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * @access private
 * @typedef {CanvasRenderingContext2D|{max: number, maxRadius: number, barDimensions: object}} Canvas2DContext
 */

/* istanbul ignore next: private, not testable */
/**
 * Examines if a given error is something to throw or to ignore
 *
 * @param {Error} err
 */
function verifyError(err) {
    // there is some unpredictable error in FF in some circumstances
    // which we found simply safe to ignore than to fight with it
    // noinspection JSUnresolvedVariable
    if (err instanceof DOMException && err.result === 0x8053000b) {
        return ; // ignore it
    }

    throw err;
}

/* istanbul ignore next: private, not testable */
/**
 * Prepares major ticks data
 *
 * @access private
 * @param {GenericOptions|{ tickSide: string }} options
 * @return {[boolean, boolean]}
 */
function prepareTicks(options) {
    if (!(options.majorTicks instanceof Array)) {
        options.majorTicks = options.majorTicks ? [options.majorTicks] : [];
    }

    if (!options.majorTicks.length) {
        options.majorTicks.push(drawings.formatMajorTickNumber(
            options.minValue, options));
        options.majorTicks.push(drawings.formatMajorTickNumber(
            options.maxValue, options));
    }

    return [options.tickSide !== 'right', options.tickSide !== 'left'];
}

/* istanbul ignore next: private, not testable */
/**
 * Draws rounded corners rectangle
 *
 * @param {Canvas2DContext} context
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @param {number} r
 */
function roundRect(context, x, y, w, h, r) {
    context.beginPath();

    context.moveTo(x + r, y);
    context.lineTo(x + w - r, y);

    context.quadraticCurveTo(x + w, y, x + w, y + r);
    context.lineTo(x + w, y + h - r);

    context.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    context.lineTo(x + r, y + h);

    context.quadraticCurveTo(x, y + h, x, y + h - r);
    context.lineTo(x, y + r);

    context.quadraticCurveTo(x, y, x + r, y);

    context.closePath();
}

/* istanbul ignore next: private, not testable */
/**
 * Pads a given value with leading zeros using the given options
 *
 * @param {number} val
 * @param {RadialGaugeOptions|{valueInt: number, valueDec: number}} options
 * @returns {string}
 */
function padValue(val, options) {
    let dec = options.valueDec;
    let int = options.valueInt;
    let i = 0;
    let s, strVal, n;

    val = parseFloat(val);
    n = (val < 0);
    val = Math.abs(val);

    if (dec > 0) {
        strVal = val.toFixed(dec).toString().split('.');
        s = int - strVal[0].length;

        for (; i < s; ++i) {
            strVal[0] = '0' + strVal[0];
        }

        strVal = (n ? '-' : '') + strVal[0] + '.' + strVal[1];
    }

    else {
        strVal = Math.round(val).toString();
        s = int - strVal.length;

        for (; i < s; ++i) {
            strVal = '0' + strVal;
        }

        strVal = (n ? '-' : '') + strVal;
    }

    return strVal;
}

/* istanbul ignore next: private, not testable */
/**
 * Formats a number for display on the dial's plate using the majorTicksFormat
 * config option.
 *
 * @param {number} num number to format
 * @param {object} options
 * @returns {string} formatted number
 */
function formatMajorTickNumber(num, options) {
    let right, hasDec = false;

    // First, force the correct number of digits right of the decimal.
    if (options.majorTicksDec === 0) {
        right = Math.round(num).toString();
    }

    else {
        right = num.toFixed(options.majorTicksDec);
    }

    // Second, force the correct number of digits left of the decimal.
    if (options.majorTicksInt > 1) {
        // Does this number have a decimal?
        hasDec = ~right.indexOf('.');

        // Is this number a negative number?
        if (~right.indexOf('-')) {
            return '-' + [
                    options.majorTicksInt +
                    options.majorTicksDec +
                    2 + (hasDec ? 1 : 0) - right.length
                ].join('0') + right.replace('-', '');
        }

        else {
            return [
                    options.majorTicksInt +
                    options.majorTicksDec +
                    1 + (hasDec ? 1 : 0) - right.length
                ].join('0') + right;
        }
    }

    return right;
}

/* istanbul ignore next: private, not testable */
/**
 * Transforms degrees to radians
 *
 * @param {number} degrees
 * @returns {number}
 */
function radians(degrees) {
    return degrees * Math.PI / 180;
}

/* istanbul ignore next: private, not testable */
/**
 * Calculates and returns radial point coordinates
 *
 * @param {number} radius
 * @param {number} angle
 * @returns {{x: number, y: number}}
 */
function radialPoint(radius, angle) {
    return { x: -radius * Math.sin(angle), y: radius * Math.cos(angle) };
}

/* istanbul ignore next: private, not testable */
/**
 * Creates and returns linear gradient canvas object
 *
 * @param {Canvas2DContext} context
 * @param {string} colorFrom
 * @param {string} colorTo
 * @param {number} length
 * @param {boolean} [isVertical]
 * @param {number} [from]
 * @returns {CanvasGradient}
 */
function linearGradient(context, colorFrom, colorTo, length,
                               isVertical = true, from = 0)
{
    let grad = context.createLinearGradient(
        isVertical ? 0 : from,
        isVertical ? from : 0,
        isVertical ? 0 : length,
        isVertical ? length : 0);

    grad.addColorStop(0, colorFrom);
    grad.addColorStop(1, colorTo);

    return grad;
}

/* istanbul ignore next: private, not testable */
/**
 * Draws the shadow if it was not drawn
 *
 * @param {Canvas2DContext} context
 * @param {GenericOptions} options
 * @param {boolean} shadowDrawn
 * @return {boolean}
 */
function drawShadow(context, options, shadowDrawn = false) {
    if (shadowDrawn) {
        context.restore();
        return true;
    }

    context.save();

    let w =  options.borderShadowWidth;

    if (w) {
        context.shadowBlur = w;
        context.shadowColor = options.colorBorderShadow;
    }

    return true;
}

/* istanbul ignore next: private, not testable */
/**
 * Draws gauge needle shadow
 *
 * @access private
 * @param {Canvas2DContext} context
 * @param {RadialGaugeOptions} options
 */
function drawNeedleShadow(context, options) {
    if (!options.needleShadow) return;

    context.shadowOffsetX = 2;
    context.shadowOffsetY = 2;
    context.shadowBlur = 10;
    context.shadowColor = options.colorNeedleShadowDown;
}

/* istanbul ignore next: private, not testable */
/**
 * Constructs font styles for canvas fonts
 *
 * @param {GenericOptions} options
 * @param {string} target
 * @param {number} baseSize
 */
function font(options, target, baseSize) {
    return options['font' + target + 'Style'] + ' ' +
        options['font' + target + 'Weight'] + ' ' +
        options['font' + target + 'Size'] * baseSize + 'px ' +
        options['font' + target];
}

/* istanbul ignore next: private, not testable */
/**
 * Resets some context settings
 *
 * @param {Canvas2DContext} context
 */
function reset(context) {
    context.shadowOffsetX = null;
    context.shadowOffsetY = null;
    context.shadowBlur = null;
    context.shadowColor = '';
    context.strokeStyle = null;
    context.lineWidth = 0;
    context.save();
}

/* istanbul ignore next: private, not testable */
/**
 * Declares to drow value text shadow if configured
 *
 * @param context
 * @param options
 * @param offset
 * @param blur
 */
function drawValueTextShadow(context, options, offset, blur) {
    if (options.valueTextShadow) {
        context.shadowOffsetX = offset;
        context.shadowOffsetY = offset;
        context.shadowBlur = blur;
        context.shadowColor = options.colorValueTextShadow;
    }
}

/* istanbul ignore next: private, not testable */
/**
 * Draws value box at given position
 *
 * @param {Canvas2DContext} context
 * @param {GenericOptions} options
 * @param {number|string} value
 * @param {number} x
 * @param {number} y
 * @param {number} max
 */
function drawValueBox(context, options, value, x, y, max) {
    if (!options.valueBox) return;

    reset(context);

    let addLength = (options.valueDec ? 1 + options.valueDec : 0);
    let maxValueWidth = '9'.repeat(Math.max.apply(null,
        [String(parseInt(value)).length + addLength]
        .concat(options.majorTicks.map(val =>
            String(parseInt(val, 10)).length + addLength
        ))));
    let text = options.valueText || padValue(value, options);
    let tunit = max / 200;
    let runit = max / 100;
    let offset = 0.4 * runit;
    let blur = 1.2 * runit;

    context.font = font(options, 'Value', tunit);
    drawValueTextShadow(context, options, offset, blur);

    let tw = context.measureText(options.valueText ?
        text : ('-' + padValue(Number(maxValueWidth), options))).width;

    reset(context);

    let th = parseFloat(options.fontValueSize) * tunit + offset + blur;
    let sw = runit * parseFloat(options.valueBoxStroke);
    let bmax = max * 2 - sw * 2;

    let bw = tw + 10 * runit;
    let bh = 1.1 * th + offset + blur;
    let br = runit * options.valueBoxBorderRadius;
    let obw = (parseFloat(options.valueBoxWidth) || 0) / 100 * bmax;

    (obw > bw) && (bw = obw);
    (bw > bmax) && (bw = bmax);

    let bx = x - bw / 2;
    let by = y - bh / 2;
    let gy = y - 5.75 * runit;

    context.beginPath();

    if (br) roundRect(context, bx, by, bw, bh, br);
    else  context.rect(bx, by, bw, bh);

    if (sw) {
        let grd = context.createRadialGradient(
            x, gy, runit * 10, x, gy, runit * 20);

        grd.addColorStop(0, options.colorValueBoxRect);
        grd.addColorStop(1, options.colorValueBoxRectEnd);

        context.strokeStyle = grd;
        context.lineWidth = sw;
        context.stroke();
    }

    if (options.colorValueBoxShadow) {
        context.shadowBlur = 1.2 * runit;
        context.shadowColor = options.colorValueBoxShadow;
    }

    if (options.colorValueBoxBackground) {
        context.fillStyle = options.colorValueBoxBackground;
        context.fill();
    }

    context.closePath();
    context.restore();

    drawValueTextShadow(context, options, offset, blur);

    context.fillStyle = options.colorValueText;
    context.textAlign = 'center';
    context.textBaseline = 'alphabetic';
    context.fillText(text, bx + bw / 2, y + bh / 2 - th / 3);
    context.restore();
}

/* istanbul ignore next: private, not testable */
/**
 * Returns normalized value
 *
 * @param {GenericOptions} options
 * @return {{normal: number, indented: number}}
 */
function normalizedValue(options) {
    let value = options.value;
    let min = options.minValue;
    let max = options.maxValue;
    let dt = (max - min) * 0.01;

    return {
        normal: value < min ? min : value > max ? max : value,
        indented: value < min ? min - dt : value > max ? max + dt : value
    };
}

const drawings = {
    roundRect: roundRect,
    padValue: padValue,
    formatMajorTickNumber: formatMajorTickNumber,
    radians: radians,
    radialPoint: radialPoint,
    linearGradient: linearGradient,
    drawNeedleShadow: drawNeedleShadow,
    drawValueBox: drawValueBox,
    verifyError: verifyError,
    prepareTicks: prepareTicks,
    drawShadow: drawShadow,
    font: font,
    normalizedValue: normalizedValue
};

drawings;


/*!
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Mykhailo Stadnyk <mikhus@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */







const PI = Math.PI;
const HPI = PI / 2;

/**
 * Gauge configuration options
 *
 * @typedef {GenericOptions|{exactTicks: boolean, ticksAngle: number, startAngle: number, colorNeedleCircleOuter: string, colorNeedleCircleOuterEnd: string, colorNeedleCircleInner: string, colorNeedleCircleInnerEnd: string, needleCircleSize: number, needleCircleInner: boolean, needleCircleOuter: boolean, animationTarget: string, useMinPath: boolean}} RadialGaugeOptions
 */

/**
 * Default gauge configuration options
 *
 * @access private
 * @type {RadialGaugeOptions}
 */
const defaultRadialGaugeOptions = Object.assign({}, GenericOptions, {
    // basic options
    ticksAngle: 270,
    startAngle: 45,

    // colors
    colorNeedleCircleOuter: '#f0f0f0',
    colorNeedleCircleOuterEnd: '#ccc',
    colorNeedleCircleInner: '#e8e8e8',
    colorNeedleCircleInnerEnd: '#f5f5f5',

    // needle
    needleCircleSize: 10,
    needleCircleInner: true,
    needleCircleOuter: true,
    needleStart: 20,

    // custom animations
    animationTarget: 'needle', // 'needle' or 'plate'
    useMinPath: false,

    barWidth: 0
});

/* istanbul ignore next: private, not testable */
/**
 * Draws gradient-filled circle on a canvas
 *
 * @access private
 * @param {number} radius
 * @param {number} width
 * @param {Canvas2DContext} context
 * @param {string} start gradient start color
 * @param {string} end gradient end color
 */
function drawRadialBorder(radius, width, context, start, end) {
    context.beginPath();
    //noinspection JSUnresolvedFunction
    context.arc(0, 0, abs(radius), 0, PI * 2, true);
    context.lineWidth = width;
    context.strokeStyle = end ?
        drawings.linearGradient(context, start, end, radius) :
        start;
    context.stroke();
    context.closePath();
}

/* istanbul ignore next: private, not testable */
/**
 * Returns max radius without borders for the gauge
 *
 * @param {Canvas2DContext} context
 * @param {RadialGaugeOptions} options
 * @return {number}
 */
function maxRadialRadius(context, options) {
    let pxRatio = SmartCanvas.pixelRatio;

    if (!context.maxRadius) {
        context.maxRadius = context.max
            - options.borderShadowWidth
            - options.borderOuterWidth * pxRatio
            - options.borderMiddleWidth * pxRatio
            - options.borderInnerWidth * pxRatio
            + (options.borderOuterWidth ? 0.5 : 0)
            + (options.borderMiddleWidth ? 0.5 : 0)
            + (options.borderInnerWidth ? 0.5 : 0);
    }

    return context.maxRadius;
}

/* istanbul ignore next: private, not testable */
/**
 * Draws gauge plate on the canvas
 *
 * @access private
 * @param {Canvas2DContext} context
 * @param {RadialGaugeOptions} options
 */
function drawRadialPlate(context, options) {
    let pxRatio = SmartCanvas.pixelRatio;
    let d0 = options.borderShadowWidth * pxRatio;
    let r0 = context.max - d0 - (options.borderOuterWidth * pxRatio) / 2;
    let r1 = r0 - (options.borderOuterWidth * pxRatio) / 2 -
        (options.borderMiddleWidth * pxRatio) / 2 + 0.5;
    let r2 = r1 - (options.borderMiddleWidth * pxRatio) / 2 -
        (options.borderInnerWidth * pxRatio) / 2 + 0.5;
    let r3 = maxRadialRadius(context, options);
    let grad;
    let shadowDrawn = false;

    context.save();

    if (options.borderOuterWidth) {
        shadowDrawn = drawings.drawShadow(context, options, shadowDrawn);
        drawRadialBorder(r0,
            options.borderOuterWidth * pxRatio,
            context,
            options.colorBorderOuter,
            options.colorBorderOuterEnd);
    }

    if (options.borderMiddleWidth) {
        shadowDrawn = drawings.drawShadow(context, options, shadowDrawn);
        drawRadialBorder(r1,
            options.borderMiddleWidth * pxRatio,
            context,
            options.colorBorderMiddle,
            options.colorBorderMiddleEnd);
    }

    if (options.borderInnerWidth) {
        shadowDrawn = drawings.drawShadow(context, options, shadowDrawn);
        drawRadialBorder(r2,
            options.borderInnerWidth * pxRatio,
            context,
            options.colorBorderInner,
            options.colorBorderInnerEnd);
    }

    drawings.drawShadow(context, options, shadowDrawn);

    context.beginPath();
    //noinspection JSUnresolvedFunction
    context.arc(0, 0, abs(r3), 0, PI * 2, true);

    if (options.colorPlateEnd) {
        grad = context.createRadialGradient(0, 0, r3 / 2, 0, 0, r3);
        grad.addColorStop(0, options.colorPlate);
        grad.addColorStop(1, options.colorPlateEnd);
    }

    else  {
        grad = options.colorPlate;
    }

    context.fillStyle = grad;

    context.fill();
    context.closePath();

    context.restore();
}

/* istanbul ignore next: private, not testable */
/**
 * Draws gauge highlight areas on a canvas
 *
 * @access private
 * @param {Canvas2DContext} context
 * @param {RadialGaugeOptions} options
 */
function drawRadialHighlights(context, options) {
    let hlWidth = context.max *
        (parseFloat(options.highlightsWidth) || 0) / 100;

    if (!hlWidth) return;

    //noinspection JSUnresolvedFunction
    let r = abs(radialTicksRadius(context, options) - hlWidth / 2);
    let i = 0, s = options.highlights.length;
    let vd = (options.maxValue - options.minValue) / options.ticksAngle;

    context.save();

    for (; i < s; i++) {
        let hlt = options.highlights[i];

        context.beginPath();

        context.rotate(HPI);
        context.arc(0, 0, r,
            drawings.radians(options.startAngle +
                (hlt.from - options.minValue) / vd),
            drawings.radians(options.startAngle +
                (hlt.to - options.minValue) / vd),
            false
        );
        context.strokeStyle = hlt.color;
        context.lineWidth = hlWidth;
        context.stroke();
        context.closePath();

        context.restore();
        context.save();
    }
}

/* istanbul ignore next: private, not testable */
/**
 * Draws minor ticks bar on a canvas
 *
 * @access private
 * @param {Canvas2DContext} context
 * @param {RadialGaugeOptions} options
 */
function drawRadialMinorTicks(context, options) {
    let radius = radialTicksRadius(context, options);
    let s, range, angle;
    let i = 0;
    let delta = 0;
    let minTicks = Math.abs(options.minorTicks) || 0;
    let ratio = options.ticksAngle / (options.maxValue - options.minValue);

    context.lineWidth = SmartCanvas.pixelRatio;
    context.strokeStyle = options.colorMinorTicks || options.colorStrokeTicks;

    context.save();

    if (options.exactTicks) {
        range = options.maxValue - options.minValue;
        s = minTicks ? range / minTicks : 0;
        delta = (BaseGauge.mod(options.majorTicks[0], minTicks) || 0)  * ratio;
    }

    else {
        s = minTicks * (options.majorTicks.length - 1);
    }

    for (; i < s; ++i) {
        angle = options.startAngle + delta + i * (options.ticksAngle / s);
        if (angle <= (options.ticksAngle + options.startAngle )) {
            context.rotate(drawings.radians(angle));

            context.beginPath();
            context.moveTo(0, radius);
            context.lineTo(0, radius - context.max * 0.075);
            closeStrokedPath(context);
        }
    }
}

/* istanbul ignore next: private, not testable */
/**
 * Returns ticks radius
 *
 * @access private
 * @param context
 * @param options
 * @return {number}
 */
function radialTicksRadius(context, options) {
    let unit = context.max / 100;

    return maxRadialRadius(context, options) - 5 * unit -
        (options.barWidth ?
            ((parseFloat(options.barStrokeWidth) || 0) * 2 +
            ((parseFloat(options.barWidth) || 0) + 5) * unit) :
        0);
}

/* istanbul ignore next: private, not testable */
/**
 * Draws gauge major ticks bar on a canvas
 *
 * @param {Canvas2DContext} context
 * @param {RadialGaugeOptions} options
 */
function drawRadialMajorTicks(context, options) {
    drawings.prepareTicks(options);
debugger
    //noinspection JSUnresolvedFunction
    let r = abs(radialTicksRadius(context, options));
    let i, colors;
    let s = options.majorTicks.length;
    let pixelRatio = SmartCanvas.pixelRatio;

    context.lineWidth = 2 * pixelRatio;
    context.save();

    colors = options.colorMajorTicks instanceof Array ?
        options.colorMajorTicks : new Array(s).fill(options.colorStrokeTicks ||
            options.colorMajorTicks);

    i = 0;
    for (; i < s; ++i) {
        context.strokeStyle = colors[i];
        context.rotate(drawings.radians(radialNextAngle(
            options,
            options.exactTicks ? options.majorTicks[i] : i,
            s
        )));

        context.beginPath();
        context.moveTo(0, r);
        context.lineTo(0, r - context.max * 0.15);
        closeStrokedPath(context);
    }

    if (options.strokeTicks) {
        context.strokeStyle = options.colorStrokeTicks || colors[0];
        context.rotate(HPI);

        context.beginPath();
        context.arc(0, 0, r,
            drawings.radians(options.startAngle),
            drawings.radians(options.startAngle + options.ticksAngle),
            false
        );
        closeStrokedPath(context);
    }
}

/* istanbul ignore next: private, not testable */
function radialNextAngle(options, i, s) {
    if (options.exactTicks) {
        let ratio = options.ticksAngle / (options.maxValue - options.minValue);
        return options.startAngle + ratio * (i - options.minValue);
    }

    return options.startAngle + i * (options.ticksAngle / (s - 1));
}

/* istanbul ignore next: private, not testable */
/**
 * Strokes, closes path and restores previous context state
 *
 * @param {Canvas2DContext} context
 */
function closeStrokedPath(context) {
    context.stroke();
    context.restore();
    context.closePath();
    context.save();
}

/* istanbul ignore next: private, not testable */
/**
 * Draws gauge bar numbers
 *
 * @access private
 * @param {Canvas2DContext} context
 * @param {RadialGaugeOptions} options
 */
function drawRadialNumbers(context, options) {
    let radius = radialTicksRadius(context, options) - context.max * 0.15;
    let points = {};
    let i = 0;
    let s = options.majorTicks.length;
    let isAnimated = options.animationTarget !== 'needle';
    let colors = options.colorNumbers instanceof Array ?
        options.colorNumbers : new Array(s).fill(options.colorNumbers);

    let plateValueAngle = isAnimated ? -(options.value - options.minValue) /
        (options.maxValue - options.minValue) * options.ticksAngle : 0;

    if (isAnimated) {
        context.save();
        context.rotate(-drawings.radians(plateValueAngle));
    }

    context.font = drawings.font(options, 'Numbers', context.max / 200);
    context.lineWidth = 0;
    context.textAlign = 'center';
    context.textBaseline = 'middle';

    for (; i < s; ++i) {
        let angle = plateValueAngle + radialNextAngle(options,
            options.exactTicks ? options.majorTicks[i] : i, s);
        let textWidth = context.measureText(options.majorTicks[i]).width;
        let textHeight = options.fontNumbersSize;
        let textRadius = Math.sqrt(textWidth * textWidth +
            textHeight * textHeight) / 2;
        let point = drawings.radialPoint(radius - textRadius -
            options.numbersMargin / 100 * context.max,
            drawings.radians(angle));

        if (angle === 360) angle = 0;

        if (points[angle]) {
            continue; //already drawn at this place, skipping
        }

        points[angle] = true;

        context.fillStyle = colors[i];
        context.fillText(options.majorTicks[i], point.x, point.y);
    }

    isAnimated && context.restore();
}

/* istanbul ignore next: private, not testable */
/**
 * Draws gauge title
 *
 * @access private
 * @param {Canvas2DContext} context
 * @param {RadialGaugeOptions} options
 */
function drawRadialTitle(context, options) {
    if (!options.title) return;

    context.save();
    context.font = drawings.font(options, 'Title', context.max / 200);
    context.fillStyle = options.colorTitle;
    context.textAlign = 'center';
    context.fillText(options.title, 0, -context.max / 4.25, context.max * 0.8);
    context.restore();
}

/* istanbul ignore next: private, not testable */
/**
 * Draws units name on the gauge
 *
 * @access private
 * @param {Canvas2DContext} context
 * @param {RadialGaugeOptions} options
 */
function drawRadialUnits(context, options) {
    if (!options.units) return;

    context.save();
    context.font = drawings.font(options, 'Units', context.max / 200);
    context.fillStyle = options.colorUnits;
    context.textAlign = 'center';
    context.fillText(options.units, 0, context.max / 3.25, context.max * 0.8);
    context.restore();
}

/* istanbul ignore next: private, not testable */
/**
 * Draws gauge needle
 *
 * @access private
 * @param {Canvas2DContext} context
 * @param {RadialGaugeOptions} options
 */
function drawRadialNeedle(context, options) {
    if (!options.needle) return;

    let value = options.ticksAngle < 360 ?
        drawings.normalizedValue(options).indented : options.value;
    let max = maxRadialRadius(context, options);
    //noinspection JSUnresolvedFunction
    let r1 = abs(max / 100 * options.needleCircleSize);
    //noinspection JSUnresolvedFunction
    let r2 = abs(max / 100 * options.needleCircleSize * 0.75);
    //noinspection JSUnresolvedFunction
    let rIn = abs(max / 100 * options.needleEnd);
    //noinspection JSUnresolvedFunction
    let rStart = abs(options.needleStart ?
            max / 100 * options.needleStart : 0);
    //noinspection JSUnresolvedFunction
    let pad1 = max / 100 * options.needleWidth;
    let pad2 = max / 100 * options.needleWidth / 2;
    let pixelRatio = SmartCanvas.pixelRatio;
    let isFixed = options.animationTarget !== 'needle';

    context.save();

    drawings.drawNeedleShadow(context, options);

    context.rotate(drawings.radians(isFixed ? options.startAngle :
        (options.startAngle + (value -
            options.minValue) / (options.maxValue - options.minValue) *
            options.ticksAngle)));

    context.fillStyle = drawings.linearGradient(
        context,
        options.colorNeedle,
        options.colorNeedleEnd,
        rIn - rStart);

    if (options.needleType === 'arrow') {
        context.beginPath();
        context.moveTo(-pad2, -rStart);
        context.lineTo(-pad1, 0);
        context.lineTo(-1 * pixelRatio, rIn);
        context.lineTo(pixelRatio, rIn);
        context.lineTo(pad1, 0);
        context.lineTo(pad2, -rStart);
        context.closePath();
        context.fill();

        context.beginPath();
        context.lineTo(-0.5 * pixelRatio, rIn);
        context.lineTo(-1 * pixelRatio, rIn);
        context.lineTo(-pad1, 0);
        context.lineTo(-pad2, -rStart);
        context.lineTo(pad2 / 2 * pixelRatio - 2 * pixelRatio, -rStart);
        context.closePath();
        context.fillStyle = options.colorNeedleShadowUp;
        context.fill();
    }

    else { // simple line needle
        context.beginPath();
        context.moveTo(-pad2, rIn);
        context.lineTo(-pad2, rStart);
        context.lineTo(pad2, rStart);
        context.lineTo(pad2, rIn);
        context.closePath();
        context.fill();
    }

    if (options.needleCircleSize) {
        context.restore();

        drawings.drawNeedleShadow(context, options);

        if (options.needleCircleOuter) {
            context.beginPath();
            context.arc(0, 0, r1, 0, PI * 2, true);
            context.fillStyle = drawings.linearGradient(
                context,
                options.colorNeedleCircleOuter,
                options.colorNeedleCircleOuterEnd,
                r1
            );
            context.fill();
            context.closePath();
        }

        if (options.needleCircleInner) {
            context.beginPath();
            context.arc(0, 0, r2, 0, PI * 2, true);
            context.fillStyle = drawings.linearGradient(
                context,
                options.colorNeedleCircleInner,
                options.colorNeedleCircleInnerEnd,
                r2
            );
            context.fill();
            context.closePath();
        }

        context.restore();
    }
}

/* istanbul ignore next: private, not testable */
/**
 * Draws gauge value box
 *
 * @param {Canvas2DContext} context
 * @param {RadialGaugeOptions} options
 * @param {number} value
 */
function drawRadialValueBox(context, options, value) {
    drawings.drawValueBox(context, options, value, 0,
        context.max - context.max * 0.33, context.max);
}

/* istanbul ignore next: private, not testable */
/**
 * Draws gauge progress bar
 *
 * @param {Canvas2DContext} context
 * @param {RadialGaugeOptions} options
 */
function drawRadialProgressBar(context, options) {
    let unit = context.max / 100;
    let rMax = maxRadialRadius(context, options) - 5 * unit;
    let sw = (parseFloat(options.barStrokeWidth) || 0);
    let w = (parseFloat(options.barWidth) || 0) * unit;
    let rMin = rMax - sw * 2 - w;
    let half = (rMax- rMin) / 2;
    let r = rMin + half;
    let delta = sw / r;
    let sa = options.startAngle;
    let ea = options.startAngle + options.ticksAngle;

    context.save();
    context.rotate(HPI);

    if (sw) {
        // draw stroke
        context.beginPath();
        context.arc(0, 0, r, drawings.radians(sa) - delta,
            drawings.radians(ea) + delta, false);
        context.strokeStyle = options.colorBarStroke;
        context.lineWidth = half * 2;
        context.stroke();
        context.closePath();
    }

    if (w) {
        // draw bar
        context.beginPath();
        context.arc(0, 0, r, drawings.radians(sa), drawings.radians(ea), false);
        context.strokeStyle = options.colorBar;
        context.lineWidth = w;
        context.stroke();
        context.closePath();

        if  (options.barShadow) {
            // draw shadow
            context.beginPath();
            context.arc(0, 0, rMax, drawings.radians(sa), drawings.radians(ea),
                false);
            context.clip();

            context.beginPath();
            context.strokeStyle = options.colorBar;
            context.lineWidth = 1;
            context.shadowBlur = options.barShadow;
            context.shadowColor = options.colorBarShadow;
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
            context.arc(0, 0, rMax,
                drawings.radians(options.startAngle),
                drawings.radians(options.startAngle + options.ticksAngle),
                false);
            context.stroke();
            context.closePath();

            context.restore();
            context.rotate(HPI);
        }

        // draw bar progress
        if (options.barProgress) {
            context.beginPath();
            context.arc(0, 0, r,
                drawings.radians(sa),
                drawings.radians(sa +
                    (drawings.normalizedValue(options).normal -
                    options.minValue) / (options.maxValue - options.minValue) *
                    options.ticksAngle),
                false);
            context.strokeStyle = options.colorBarProgress;
            context.lineWidth = w;
            context.stroke();
            context.closePath();
        }
    }

    context.restore();
}

/**
 * Find and return gauge value to display
 *
 * @param {RadialGauge} gauge
 */
function displayValue(gauge) {
    if (gauge.options.animatedValue) {
        return gauge.options.value;
    }

    return gauge.value;
}

/**
 * Minimalistic HTML5 Canvas Gauge
 * @example
 *  var gauge = new RadialGauge({
 *     renderTo: 'gauge-id', // identifier of HTML canvas element or element itself
 *     width: 400,
 *     height: 400,
 *     units: 'Km/h',
 *     title: false,
 *     value: 0,
 *     minValue: 0,
 *     maxValue: 220,
 *     majorTicks: [
 *         '0','20','40','60','80','100','120','140','160','180','200','220'
 *     ],
 *     minorTicks: 2,
 *     strokeTicks: false,
 *     highlights: [
 *         { from: 0, to: 50, color: 'rgba(0,255,0,.15)' },
 *         { from: 50, to: 100, color: 'rgba(255,255,0,.15)' },
 *         { from: 100, to: 150, color: 'rgba(255,30,0,.25)' },
 *         { from: 150, to: 200, color: 'rgba(255,0,225,.25)' },
 *         { from: 200, to: 220, color: 'rgba(0,0,255,.25)' }
 *     ],
 *     colorPlate: '#222',
 *     colorMajorTicks: '#f5f5f5',
 *     colorMinorTicks: '#ddd',
 *     colorTitle: '#fff',
 *     colorUnits: '#ccc',
 *     colorNumbers: '#eee',
 *     colorNeedleStart: 'rgba(240, 128, 128, 1)',
 *     colorNeedleEnd: 'rgba(255, 160, 122, .9)',
 *     valueBox: true,
 *     animationRule: 'bounce'
 * });
 * // draw initially
 * gauge.draw();
 * // animate
 * setInterval(() => {
 *    gauge.value = Math.random() * -220 + 220;
 * }, 1000);
 */
class RadialGauge extends BaseGauge {

    /**
     * Fired each time before gauge plate is drawn
     *
     * @event RadialGauge#beforePlate
     */

    /**
     * Fired each time before gauge highlight areas are drawn
     *
     * @event RadialGauge#beforeHighlights
     */

    /**
     * Fired each time before gauge minor ticks are drawn
     *
     * @event RadialGauge#beforeMinorTicks
     */

    /**
     * Fired each time before gauge major ticks are drawn
     *
     * @event RadialGauge#beforeMajorTicks
     */

    /**
     * Fired each time before gauge tick numbers are drawn
     *
     * @event RadialGauge#beforeNumbers
     */

    /**
     * Fired each time before gauge title is drawn
     *
     * @event RadialGauge#beforeTitle
     */

    /**
     * Fired each time before gauge units text is drawn
     *
     * @event RadialGauge#beforeUnits
     */

    /**
     * Fired each time before gauge progress bar is drawn
     *
     * @event RadialGauge#beforeProgressBar
     */

    /**
     * Fired each time before gauge value box is drawn
     *
     * @event RadialGauge#beforeValueBox
     */

    /**
     * Fired each time before gauge needle is drawn
     *
     * @event RadialGauge#beforeNeedle
     */

    /**
     * @constructor
     * @param {RadialGaugeOptions} options
     */
    constructor(options) {
        options = Object.assign({}, defaultRadialGaugeOptions, options || {});
        super(RadialGauge.configure(options));
    }

    /**
     * Checks and updates gauge options properly
     *
     * @param {*} options
     * @return {*}
     * @access protected
     */
    static configure(options) {
        if (options.barWidth > 50) options.barWidth = 50;

        /* istanbul ignore if */
        if (isNaN(options.startAngle)) options.startAngle = 45;
        /* istanbul ignore if */
        if (isNaN(options.ticksAngle)) options.ticksAngle = 270;

        /* istanbul ignore if */
        if (options.ticksAngle > 360) options.ticksAngle = 360;
        /* istanbul ignore if */
        if (options.ticksAngle < 0) options.ticksAngle = 0;

        /* istanbul ignore if */
        if (options.startAngle < 0) options.startAngle = 0;
        /* istanbul ignore if */
        if (options.startAngle > 360) options.startAngle = 360;

        return options;
    }

    /**
     * Sets the value for radial gauge
     *
     * @param {number} value
     */
    set value(value) {
        value = BaseGauge.ensureValue(value, this.options.minValue);

        if (this.options.animation &&
            this.options.ticksAngle === 360 &&
            this.options.useMinPath
        ) {
            this._value = value;
            value = this.options.value +
                ((((value - this.options.value) % 360) + 540) % 360) - 180;
        }

        super.value = value;
    }

    /**
     * Returns current gauge value
     *
     * @return {number}
     */
    get value() {
        return super.value;
    }

    /**
     * Triggering gauge render on a canvas.
     *
     * @returns {RadialGauge}
     */
    draw() {
        try {
            let canvas = this.canvas;
            let [x, y, w, h] = [
                -canvas.drawX,
                -canvas.drawY,
                canvas.drawWidth,
                canvas.drawHeight
            ];
            let options = this.options;

            if (options.animationTarget === 'needle') {
                if (!canvas.elementClone.initialized) {
                    let context = canvas.contextClone;

                    // clear the cache
                    context.clearRect(x, y, w, h);
                    context.save();

                    this.emit('beforePlate');
                    drawRadialPlate(context, options);
                    this.emit('beforeHighlights');
                    drawRadialHighlights(context, options);
                    this.emit('beforeMinorTicks');
                    drawRadialMinorTicks(context, options);
                    this.emit('beforeMajorTicks');
                    drawRadialMajorTicks(context, options);
                    this.emit('beforeNumbers');
                    drawRadialNumbers(context, options);
                    this.emit('beforeTitle');
                    drawRadialTitle(context, options);
                    this.emit('beforeUnits');
                    drawRadialUnits(context, options);

                    canvas.elementClone.initialized = true;
                }

                this.canvas.commit();

                // clear the canvas
                canvas.context.clearRect(x, y, w, h);
                canvas.context.save();

                canvas.context.drawImage(canvas.elementClone, x, y, w, h);
                canvas.context.save();

                this.emit('beforeProgressBar');
                drawRadialProgressBar(canvas.context, options);
                this.emit('beforeValueBox');
                drawRadialValueBox(canvas.context, options, displayValue(this));
                this.emit('beforeNeedle');
                drawRadialNeedle(canvas.context, options);
            }

            else {
                let plateValueAngle = -drawings.radians(
                    (options.value - options.minValue) /
                    (options.maxValue - options.minValue) *
                    options.ticksAngle);

                // clear the canvas
                canvas.context.clearRect(x, y, w, h);
                canvas.context.save();

                this.emit('beforePlate');
                drawRadialPlate(canvas.context, options);

                canvas.context.rotate(plateValueAngle);

                // animated
                this.emit('beforeHighlights');
                drawRadialHighlights(canvas.context, options);
                this.emit('beforeMinorTicks');
                drawRadialMinorTicks(canvas.context, options);
                this.emit('beforeMajorTicks');
                drawRadialMajorTicks(canvas.context, options);
                this.emit('beforeNumbers');
                drawRadialNumbers(canvas.context, options);
                this.emit('beforeProgressBar');
                drawRadialProgressBar(canvas.context, options);

                // non-animated
                canvas.context.rotate(-plateValueAngle);
                canvas.context.save();

                if (!canvas.elementClone.initialized) {
                    let context = canvas.contextClone;

                    // clear the cache
                    context.clearRect(x, y, w, h);
                    context.save();

                    this.emit('beforeTitle');
                    drawRadialTitle(context, options);
                    this.emit('beforeUnits');
                    drawRadialUnits(context, options);
                    this.emit('beforeNeedle');
                    drawRadialNeedle(context, options);

                    canvas.elementClone.initialized = true;
                }

                canvas.context.drawImage(canvas.elementClone, x, y, w, h);
            }

            // value box animations
            this.emit('beforeValueBox');
            drawRadialValueBox(canvas.context, options, displayValue(this));

            super.draw();
        }

        catch (err) {
           drawings.verifyError(err);
        }

        return this;
    }
}


/**
 * @ignore
 * @typedef {object} ns
 */
/* istanbul ignore if */
if (typeof ns !== 'undefined') {
    ns['RadialGauge'] = RadialGauge;
}

BaseGauge.initialize('RadialGauge', defaultRadialGaugeOptions);


/*!
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Mykhailo Stadnyk <mikhus@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */







/**
 * Linear gauge configuration options
 *
 * @typedef {GenericOptions|{borderRadius: number, barBeginCircle: number, tickSide: string, needleSide: string, numberSide: string, ticksWidth: number, ticksWidthMinor: number, ticksPadding: number, barLength: number, colorBarEnd: string, colorBarProgressEnd: string}} LinearGaugeOptions
 */

/**
 * Default linear gauge configuration options
 *
 * @type {LinearGaugeOptions}
 */
let defaultLinearGaugeOptions = Object.assign({}, GenericOptions, {
    // basic options
    borderRadius: 0,
    // width: 150,
    // height: 400,

    // bar
    barBeginCircle: 30, // percents
    colorBarEnd: '',
    colorBarProgressEnd: '',

    needleWidth: 6,

    tickSide: 'both', // available: 'left', 'right', 'both'
    needleSide: 'both', // available: 'left', 'right', 'both'

    numberSide: 'both', // available: 'left', 'right', 'both'

    ticksWidth: 10,
    ticksWidthMinor: 5,
    ticksPadding: 5,
    barLength: 85,
    fontTitleSize: 26,

    highlightsWidth: 10
});

/* istanbul ignore next: private, not testable */
/**
 * Draws rectangle on a canvas
 *
 * @param {Canvas2DContext} context
 * @param {number} r radius for founded corner rectangle if 0 or less won't be drawn
 * @param {number} x x-coordinate of the top-left corner
 * @param {number} y y-coordinate of the top-left corner
 * @param {number} w width of the rectangle
 * @param {number} h height of the rectangle
 * @param {string} colorStart base fill color of the rectangle
 * @param {string} [colorEnd] gradient color of the rectangle
 */
function drawRectangle(context, r, x, y, w, h, colorStart, colorEnd) {
    context.beginPath();
    context.fillStyle = colorEnd ?
        drawings.linearGradient(context, colorStart, colorEnd,
            w > h ? w: h, h > w, w > h ? x : y) : colorStart;

    (r > 0)  ?
        drawings.roundRect(context, x, y, w, h, r) :
        context.rect(x, y, w, h);

    context.fill();
    context.closePath();
}

/* istanbul ignore next: private, not testable */
/**
 * Draws rectangle on a canvas
 *
 * @param {Canvas2DContext} context
 * @param {number} width width of the border
 * @param {number} r radius for founded corner rectangle if 0 or less won't be drawn
 * @param {number} x x-coordinate of the top-left corner
 * @param {number} y y-coordinate of the top-left corner
 * @param {number} w width of the rectangle
 * @param {number} h height of the rectangle
 * @param {string} colorStart base fill color of the rectangle
 * @param {string} [colorEnd] gradient color of the rectangle
 */
function drawLinearBorder(context, width, r, x, y, w, h, colorStart, colorEnd) {
    context.beginPath();
    context.lineWidth = width;
    context.strokeStyle = colorEnd ?
        drawings.linearGradient(context, colorStart, colorEnd, h, true, y) :
        colorStart;

    (r > 0)  ?
        drawings.roundRect(context, x, y, w, h, r) :
        context.rect(x, y, w, h);

    context.stroke();
    context.closePath();
}

/* istanbul ignore next: private, not testable */
/**
 * Draws linear gauge plate
 *
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions} options
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 */
function drawLinearPlate(context, options, x, y, w, h) {
    let pxRatio = SmartCanvas.pixelRatio;
    context.save();

    let r = options.borderRadius * pxRatio;
    let w1 = w - options.borderShadowWidth - options.borderOuterWidth * pxRatio;
    let w2 = w1 - options.borderOuterWidth * pxRatio -
        options.borderMiddleWidth * pxRatio;
    let w3 = w2 - options.borderMiddleWidth * pxRatio -
        options.borderInnerWidth * pxRatio;
    let w4 = w3 - options.borderInnerWidth * pxRatio;

    let h1 = h - options.borderShadowWidth - options.borderOuterWidth * pxRatio;
    let h2 = h1 - options.borderOuterWidth * pxRatio -
        options.borderMiddleWidth * pxRatio;
    let h3 = h2 - options.borderMiddleWidth * pxRatio -
        options.borderInnerWidth * pxRatio;
    let h4 = h3 - options.borderInnerWidth * pxRatio;

    let x2 = x - (w2 - w1) / 2;
    let x3 = x2 - (w3 - w2) / 2;
    let x4 = x3 - (w4 - w3) / 2;

    let y2 = y - (h2 - h1) / 2;
    let y3 = y2 - (h3 - h2) / 2;
    let y4 = y3 - (h4 - h3) / 2;
    let aliasingOffset = 0;
    let shadowDrawn = false;

    if (options.borderOuterWidth) {
        shadowDrawn = drawings.drawShadow(context, options, shadowDrawn);
        drawLinearBorder(context, options.borderOuterWidth * pxRatio,
            r,
            x + options.borderOuterWidth * pxRatio / 2 - aliasingOffset,
            y + options.borderOuterWidth * pxRatio / 2 - aliasingOffset,
            w1, h1,
            options.colorBorderOuter,
            options.colorBorderOuterEnd);
        aliasingOffset += 0.5 * pxRatio;
    }

    if (options.borderMiddleWidth) {
        shadowDrawn = drawings.drawShadow(context, options, shadowDrawn);
        drawLinearBorder(context, options.borderMiddleWidth * pxRatio,
            (r -= 1 + aliasingOffset * 2),
            x2 + options.borderMiddleWidth * pxRatio / 2 - aliasingOffset,
            y2 + options.borderMiddleWidth * pxRatio / 2 - aliasingOffset,
            w2 + aliasingOffset * 2,
            h2 + aliasingOffset * 2,
            options.colorBorderMiddle,
            options.colorBorderMiddleEnd);
        aliasingOffset += 0.5 * pxRatio;
    }

    if (options.borderInnerWidth) {
        shadowDrawn = drawings.drawShadow(context, options, shadowDrawn);
        drawLinearBorder(context,options.borderInnerWidth * pxRatio,
            (r -= 1 + aliasingOffset * 2),
            x3 + options.borderInnerWidth * pxRatio / 2 - aliasingOffset,
            y3 + options.borderInnerWidth * pxRatio / 2 - aliasingOffset,
            w3 + aliasingOffset * 2,
            h3 + aliasingOffset * 2,
            options.colorBorderInner,
            options.colorBorderInnerEnd);
        aliasingOffset += 0.5 * pxRatio;
    }

    drawings.drawShadow(context, options, shadowDrawn);

    drawRectangle(context, r, x4, y4,
        w4 + aliasingOffset * 2,
        h4 + aliasingOffset * 2,
        options.colorPlate,
        options.colorPlateEnd);

    context.restore();

    return [x4, y4, w4, h4];
}

/* istanbul ignore next: private, not testable */
/**
 * Calculates and returns linear gauge base bar dimensions.
 *
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions|{barStrokeWidth: number, barBeginCircle: number, barWidth: number, hasLeft: boolean, hasRight: boolean}} options
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @return {{isVertical: boolean, width: number, length: number, barWidth: number, barLength: number, strokeWidth: number, barMargin: number, radius: number, x0: number, y0: number, barOffset: number, titleMargin: number, unitsMargin: number, X: number, Y: number, baseX: number, baseY: number, ticksPadding: number}}
 */
function barDimensions(context, options, x, y, w, h) {
    let pixelRatio = SmartCanvas.pixelRatio;
    let isVertical = h >= w;
    let width = isVertical ? w * 0.85 : h;
    let length = isVertical ? h : w;

    //noinspection JSUnresolvedFunction
    x = isVertical ? round(x + (w - width) / 2) : x;

    let hasTitle = !!options.title;
    let hasUnits = !!options.units;
    let hasValue = !!options.valueBox;

    let titleMargin;
    let unitsMargin;
    let valueMargin;

    if (isVertical) {
        //noinspection JSUnresolvedFunction
        unitsMargin = round(length * 0.05);
        //noinspection JSUnresolvedFunction
        titleMargin = round(length * 0.075);
        //noinspection JSUnresolvedFunction
        valueMargin = round(length * 0.11);

        if (hasTitle) {
            length -= titleMargin;
            y += titleMargin;
        }

        if (hasUnits) length -= unitsMargin;
        if (hasValue) length -= valueMargin;
    }

    else {
        //noinspection JSUnresolvedFunction
        unitsMargin = titleMargin = round(width * 0.15);

        if (hasTitle) {
            width -= titleMargin;
            y += titleMargin;
        }

        if (hasUnits) width -= unitsMargin;
    }

    let strokeWidth = options.barStrokeWidth * 2;
    //noinspection JSUnresolvedFunction
    let radius = options.barBeginCircle ?
        round(width * options.barBeginCircle / 200 - strokeWidth / 2) : 0;
    //noinspection JSUnresolvedFunction
    let barWidth = round(width * options.barWidth / 100 - strokeWidth);
    //noinspection JSUnresolvedFunction
    let barLength = round(length * options.barLength / 100 - strokeWidth);
    //noinspection JSUnresolvedFunction
    let barMargin = round((length - barLength) / 2);

    // coordinates for arc of the bar if configured
    //noinspection JSUnresolvedFunction
    let x0 = round(x + (isVertical ? width / 2 : barMargin + radius));
    //noinspection JSUnresolvedFunction
    let y0 = round(y + (isVertical ?
        length - barMargin - radius + strokeWidth / 2:
        width / 2));
    let dx = isVertical && !(options.hasLeft && options.hasRight) ?
        ((options.hasRight ? -1 : 1) * options.ticksWidth / 100 * width) : 0;
    let dy = !isVertical && !(options.hasLeft && options.hasRight) ?
        ((options.hasRight ? -1 : 1) * options.ticksWidth / 100 * width) : 0;

    //noinspection JSUndefinedPropertyAssignment
    context.barDimensions = {
        isVertical: isVertical,
        width: width,
        length: length,
        barWidth: barWidth,
        barLength: barLength,
        strokeWidth: strokeWidth,
        barMargin: barMargin,
        radius: radius,
        pixelRatio: pixelRatio,
        barOffset: null,
        titleMargin: hasTitle ? titleMargin : 0,
        unitsMargin: hasUnits ? unitsMargin : 0,
        get ticksLength() {
            return this.barLength - this.barOffset - this.strokeWidth;
        },
        X: x + dx,
        Y: y + dy,
        x0: x0 + dx,
        y0: y0 + dy,
        baseX: x,
        baseY: y,
        ticksPadding: options.ticksPadding / 100
    };

    return context.barDimensions;
}


/* istanbul ignore next: private, not testable */
/**
 * Draws bar shape from the given options on a given canvas context
 *
 * @access private
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions} options
 * @param {string} type
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 */
function drawLinearBarShape(context, options, type, x, y, w, h) {
    let {isVertical, width, barWidth, barLength, strokeWidth, barMargin, radius,
        x0, y0, X, Y} = barDimensions(context, options, x, y, w, h);
    let fullBarLength = barLength;

    context.save();
    context.beginPath();

    if (options.barBeginCircle) {
        let direction = drawings.radians(isVertical ? 270 : 0);
        let alpha = Math.asin(barWidth / 2 / radius);
        let cosAlpha = Math.cos(alpha);
        let sinAlpha = Math.sin(alpha);

        let x1 = x0 + (isVertical ?
            radius * sinAlpha :
            radius * cosAlpha - strokeWidth / 2);
        let y1 = isVertical ?
            y0 - radius * cosAlpha:
            y0 + radius * sinAlpha;
        //noinspection JSUnresolvedFunction
        let cutRadius = isVertical ? abs(y1 - y0) : abs(x1 - x0);

        //noinspection JSUnresolvedFunction
        context.barDimensions.barOffset = round(cutRadius + radius);

        // bottom point
        //noinspection JSUnresolvedFunction
        let x2 = isVertical ? round(x0 - radius * sinAlpha) : x1;
        //noinspection JSUnresolvedFunction
        let y2 = isVertical ? y1 : round(y0 - radius * sinAlpha);

        if (type === 'progress') {
            barLength = context.barDimensions.barOffset +
                (barLength - context.barDimensions.barOffset) *
                (drawings.normalizedValue(options).normal - options.minValue) /
                (options.maxValue - options.minValue);
        }

        // bar ends at
        //noinspection JSUnresolvedFunction
        let x3 = round(x1 + barLength - context.barDimensions.barOffset +
            strokeWidth / 2); // h
        //noinspection JSUnresolvedFunction
        let y3 = round(y1 - barLength + context.barDimensions.barOffset -
            strokeWidth / 2); // v

        context.arc(x0, y0, radius, direction + alpha, direction - alpha);

        if (isVertical) {
            context.moveTo(x1, y2);
            context.lineTo(x1, y3);
            context.lineTo(x2, y3);
            context.lineTo(x2, y2);
        }

        else {
            context.moveTo(x1, y2);
            context.lineTo(x3, y2);
            context.lineTo(x3, y1);
            context.lineTo(x1, y1);
        }
    }

    else {
        // simply rectangle
        //noinspection JSUnresolvedFunction
        let rx = round(isVertical ?
            (X +  (width - barWidth) / 2) : (X + barMargin));
        //noinspection JSUnresolvedFunction
        let ry = round(isVertical ?
            (Y + barLength + barMargin) : (Y +  (width - barWidth) / 2));

        if (type === 'progress') {
            barLength *= (options.value - options.minValue) /
                (options.maxValue - options.minValue);
        }

        if (isVertical) context.rect(rx, ry, barWidth, -barLength);
        else context.rect(rx, ry, barLength, barWidth);
    }

    if (type !== 'progress' && options.barStrokeWidth) {
        context.lineWidth = strokeWidth;
        context.strokeStyle = options.colorBarStroke;
        //context.lineJoin = 'round';
        context.stroke();
    }

    if (type !== 'progress' && options.colorBar) {
        context.fillStyle = options.colorBarEnd ?
            drawings.linearGradient(context, options.colorBar,
                options.colorBarEnd, barLength, isVertical,
                isVertical ? Y : X):
            options.colorBar;
        context.fill();
    }

    else if (type === 'progress' && options.colorBarProgress) {
        context.fillStyle = options.colorBarProgressEnd ?
            drawings.linearGradient(context, options.colorBarProgress,
                options.colorBarProgressEnd, fullBarLength, isVertical,
                isVertical ? Y : X):
            options.colorBarProgress;
        context.fill();
    }

    context.closePath();

    // fix dimensions for further usage
    if (options.barBeginCircle)
        context.barDimensions.radius += strokeWidth;

    context.barDimensions.barWidth += strokeWidth;
    context.barDimensions.barLength += strokeWidth;
}

/**
 * Draws gauge bar
 *
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions} options
 * @param {number} x x-coordinate of the top-left corner of the gauge
 * @param {number} y y-coordinate of the top-left corner of the gauge
 * @param {number} w width of the gauge
 * @param {number} h height of the gauge
 */
function drawLinearBar(context, options, x, y, w, h) {
    drawLinearBarShape(context, options, '', x, y, w, h);
}

/* istanbul ignore next: private, not testable */
/**
 * Helper function to calculate bar ticks presence on the sides
 *
 * @param {string} notWhich
 * @param {LinearGaugeOptions} options
 * @return {boolean}
 */
function hasTicksBar(notWhich, options) {
    return options.needleSide !== notWhich ||
            options.tickSide !== notWhich ||
            options.numberSide !== notWhich;
}

/* istanbul ignore next: private, not testable */
/**
 * Draws gauge bar progress
 *
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions} options
 * @param {number} x x-coordinate of the top-left corner of the gauge
 * @param {number} y y-coordinate of the top-left corner of the gauge
 * @param {number} w width of the gauge
 * @param {number} h height of the gauge
 */
function drawLinearBarProgress(context, options, x, y, w, h) {
    options.barProgress &&
    drawLinearBarShape(context, options, 'progress', x, y, w, h);
}

/* istanbul ignore next: private, not testable */
/**
 * Draws gauge bar highlighted areas
 *
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions} options
 */
function drawLinearBarHighlights(context, options) {
    let {isVertical, width, length, barWidth, barOffset, barMargin,
        X, Y, ticksLength, ticksPadding} = context.barDimensions;
    let hlWidth = width * (parseFloat(options.highlightsWidth) || 0) / 100;

    if (!options.highlights || !hlWidth) return ;

    let hasLeft = options.tickSide !== 'right';
    let hasRight = options.tickSide !== 'left';
    let i = 0;
    let s = options.highlights.length;
    let tickOffset = (width - barWidth) / 2;
    let interval = options.maxValue - options.minValue;
    //noinspection JSUnresolvedFunction
    let eX = round(isVertical ? X + tickOffset : X + barMargin + barOffset);
    let eH = hlWidth;
    let eY = isVertical ? Y + length - barMargin - barOffset: Y + tickOffset;
    //noinspection JSUnresolvedFunction
    let hLeft = round((options.ticksWidth / 100 + ticksPadding) * width)
        + (hlWidth - options.ticksWidth / 100 * width);
    //noinspection JSUnresolvedFunction
    let hRight = round(barWidth + ticksPadding * width);

    context.save();

    for (; i < s; i++) {
        let entry = options.highlights[i];
        //noinspection JSUnresolvedFunction
        let eStart = ticksLength * abs(options.minValue - entry.from) /
            interval;
        //noinspection JSUnresolvedFunction
        let eW = ticksLength * abs((entry.to - entry.from) / interval);

        context.beginPath();
        context.fillStyle = entry.color;

        if (isVertical) {
            if (hasLeft)
                context.rect(eX - hLeft, eY - eStart, eH, -eW);

            if (hasRight)
                context.rect(eX + hRight, eY - eStart, eH, -eW);
        }

        else {
            if (hasLeft)
                context.rect(eX + eStart, eY - hLeft, eW, eH);

            if (hasRight)
                context.rect(eX + eStart, eY + hRight, eW, eH);
        }

        context.fill();
        context.closePath();
    }
}

/* istanbul ignore next: private, not testable */
/**
 * Draws a tick line on a linear gauge
 *
 * @param {Canvas2DContext} context
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 */
function drawLinearTick(context, x1, y1, x2, y2) {
    context.beginPath();

    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.stroke();

    context.closePath();
    context.save();
}

/* istanbul ignore next: private, not testable */
/**
 * Draws ticks
 *
 * @param {Canvas2DContext} context
 * @param {string} color
 * @param {number[]} ticks
 * @param {number} minVal
 * @param {number} maxVal
 * @param {boolean} hasLeft
 * @param {boolean} hasRight
 * @param {number} lineWidth
 * @param {number} lineLength
 */
function drawLinearTicks(context,  color, ticks, minVal, maxVal,
                         hasLeft, hasRight, lineWidth, lineLength)
{
    let {isVertical, length, barWidth, barOffset, barMargin,
        pixelRatio, width, X, Y, ticksLength, ticksPadding} =
        context.barDimensions;
    let tickOffset = (width - barWidth) / 2;
    let tickX, tickY;
    let i = 0;
    let s = ticks.length;
    let val;
    let tickLen = lineLength * width;
    let tickLeft = tickOffset - ticksPadding * width;
    let tickRight = tickOffset + barWidth + tickLen + ticksPadding * width;
    let colors = color instanceof Array ?
        color : new Array(ticks.length).fill(color);

    context.lineWidth = lineWidth * pixelRatio;
    context.save();

    let ratio = ticksLength / (maxVal - minVal);
    for (; i < s; i++) {
        val = ticks[i];
        context.strokeStyle = colors[i];

        if (isVertical) {
            tickY = Y + length - barMargin - barOffset
                + (minVal - val) * ratio;

            if (hasLeft) {
                tickX = X + tickLeft;
                //noinspection JSUnresolvedFunction
                drawLinearTick(context, tickX, tickY, round(tickX - tickLen),
                    tickY);
            }

            if (hasRight) {
                tickX = X + tickRight;
                //noinspection JSUnresolvedFunction
                drawLinearTick(context, tickX, tickY, round(tickX - tickLen),
                    tickY);
            }
        }

        else {
            tickX = X + barMargin + barOffset
                - (minVal - val) * ratio;

            if (hasLeft) {
                tickY = Y + tickLeft;
                //noinspection JSUnresolvedFunction
                drawLinearTick(context, tickX, tickY, tickX,
                    round(tickY - tickLen));
            }

            if (hasRight) {
                tickY = Y + tickRight;
                //noinspection JSUnresolvedFunction
                drawLinearTick(context, tickX, round(tickY), tickX,
                    tickY - tickLen);
            }
        }
    }
}

/* istanbul ignore next: private, not testable */
/**
 * Draws major ticks
 *
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions} options
 */
function drawLinearMajorTicks(context, options) {
    let [hasLeft, hasRight] = drawings.prepareTicks(options);
    let lineWidth = 2;
    let valuePerNonExactTick = (options.maxValue - options.minValue) /
        (options.majorTicks.length - 1);
    let colors = options.colorMajorTicks instanceof Array ?
        options.colorMajorTicks :
        new Array(options.majorTicks.length).fill(
            options.colorStrokeTicks || options.colorMajorTicks);
    let ticks = options.exactTicks ? options.majorTicks :
        options.majorTicks.map((tick, i) => {
            return options.minValue + valuePerNonExactTick * i;
        });

    drawLinearTicks(context, colors, ticks, options.minValue, options.maxValue,
        hasLeft, hasRight, lineWidth, options.ticksWidth / 100);

    if (options.strokeTicks) {
        let {isVertical, length, width, barWidth, barMargin, barOffset, X, Y,
            ticksLength, pixelRatio, ticksPadding} = context.barDimensions;
        let rightTicks = (width - barWidth) / 2 + barWidth +
            ticksPadding * width;
        let leftTicks = (width - barWidth) / 2 - ticksPadding * width;
        let sX, sY, eX, eY;

        context.strokeStyle = options.colorStrokeTicks || colors[0];

        lineWidth *= pixelRatio;

        if (isVertical) {
            sY = Y + length - barMargin - barOffset + lineWidth / 2;
            eY = sY - ticksLength - lineWidth;

            if (hasLeft) {
                //noinspection JSUnresolvedFunction
                eX = sX = round(X + leftTicks);
                drawLinearTickStroke(context, sX, sY, eX, eY);
            }

            if (hasRight) {
                //noinspection JSUnresolvedFunction
                eX = sX = round(X + rightTicks);
                drawLinearTickStroke(context, sX, sY, eX, eY);
            }
        }

        else {
            sX = X + barMargin + barOffset - lineWidth / 2;
            eX = sX + ticksLength + lineWidth;

            if (hasLeft) {
                //noinspection JSUnresolvedFunction
                eY = sY = round(Y + leftTicks);
                drawLinearTickStroke(context, sX, sY, eX, eY);
            }

            if (hasRight) {
                //noinspection JSUnresolvedFunction
                eY = sY = round(Y + rightTicks);
                drawLinearTickStroke(context, sX, sY, eX, eY);
            }
        }
    }
}

/* istanbul ignore next: private, not testable */
/**
 * Draws ticks stroke
 *
 * @param {Canvas2DContext} context
 * @param {number} sX
 * @param {number} sY
 * @param {number} eX
 * @param {number} eY
 */
function drawLinearTickStroke(context, sX, sY, eX, eY) {
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(eX, eY);
    context.stroke();
    context.closePath();
}

/* istanbul ignore next: private, not testable */
/**
 * Draws minor ticks
 *
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions} options
 */
function drawLinearMinorTicks(context, options) {
    let [hasLeft, hasRight] = drawings.prepareTicks(options);
    let ticks = [];
    let i = options.minValue;
    let minTicks = Math.abs(options.minorTicks) || 0;
    let valuePerNonExactTick = minTicks ?
        (options.maxValue - options.minValue) /
        (minTicks * (options.majorTicks.length - 1)) : 0;

    if (minTicks) {
        if (options.exactTicks) {
            let delta = BaseGauge.mod(options.majorTicks[0], minTicks) || 0;

            for (; i < options.maxValue; i += minTicks) {
                if ((delta+i) < options.maxValue) {
                    ticks.push(delta + i);
                }
            }
        }

        else {
            for (; i < options.maxValue; i += valuePerNonExactTick) {
                ticks.push(i);
            }
        }
    }

    drawLinearTicks(context,
        options.colorMinorTicks || options.colorStrokeTicks,
        ticks, options.minValue, options.maxValue,
        hasLeft, hasRight, 1, options.ticksWidthMinor / 100);
}

/* istanbul ignore next: private, not testable */
/**
 * Draws major tick numbers
 *
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions} options
 */
function drawLinearMajorTicksNumbers(context, options) {
    let {isVertical, length, width, barWidth,
        barMargin, barOffset, X, Y, ticksLength, ticksPadding} =
            context.barDimensions;
    let range = (options.maxValue - options.minValue);
    let valuePerNonExactTick = range /
        (options.majorTicks.length - 1);
    let tickValues = options.exactTicks ? options.majorTicks :
        options.majorTicks.map((tick, i) => {
            return options.minValue + valuePerNonExactTick * i;
        });
    let ticks = tickValues.length;
    let hasLeft = options.numberSide !== 'right';
    let hasRight = options.numberSide !== 'left';
    let textHeight = options.fontNumbersSize * width / 200;
    let i = 0;
    let ticksWidth = (options.ticksWidth / 100 + ticksPadding * 2) * width;
    let numLeft = (width - barWidth) / 2 - ticksWidth;
    let numRight = (width - barWidth) / 2 + barWidth + ticksWidth;
    let textX, textY, textWidth, numberOffset, tick;
    let colors = options.colorNumbers instanceof Array ?
        options.colorNumbers : new Array(ticks).fill(options.colorNumbers);
    let textMargin = options.numbersMargin / 100 * width;

    context.font = drawings.font(options, 'Numbers', width / 200);
    context.lineWidth = 0;
    context.textAlign = 'center';

    for (; i < ticks; i++) {
        context.fillStyle = colors[i];
        tick = options.majorTicks[i];
        numberOffset = options.exactTicks ?
            ticksLength * ((tickValues[i] - options.minValue) / range) :
            i * ticksLength / (ticks - 1);

        if (isVertical) {
            textY = Y + length - barMargin - barOffset - numberOffset
                + textHeight / 3;

            if (hasLeft) {
                context.textAlign = 'right';
                context.fillText(tick, X + numLeft - textMargin, textY);
            }

            if (hasRight) {
                context.textAlign = 'left';
                context.fillText(tick, X + numRight + textMargin, textY);
            }
        }

        else {
            textWidth = context.measureText(tick).width;
            textX = X + barMargin + barOffset + numberOffset;

            if (hasLeft) {
                context.fillText(tick, textX, Y + numLeft - textMargin);
            }

            if (hasRight) {
                context.fillText(tick, textX, Y + numRight + textHeight +
                    textMargin);
            }
        }
    }
}

/* istanbul ignore next: private, not testable */
/**
 * Draws linear gauge title
 *
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions} options
 */
function drawLinearTitle(context, options) {
    if (!options.title) return ;

    let {isVertical, width, length, baseX, baseY, titleMargin} =
        context.barDimensions;
    let textHeight = options.fontTitleSize * width / 200;
    //noinspection JSUnresolvedFunction
    let textX = round(baseX + (isVertical ? width : length) / 2);
    //noinspection JSUnresolvedFunction
    let textY = round(baseY + titleMargin / 2 -
        (isVertical ? textHeight : textHeight / 2) -
        0.025 * (isVertical ? length : width));

    context.save();
    context.textAlign = 'center';
    context.fillStyle = options.colorTitle;
    context.font = drawings.font(options, 'Title', width / 200);
    context.lineWidth = 0;
    context.fillText(options.title, textX, textY, isVertical ? width : length);
}

/* istanbul ignore next: private, not testable */
/**
 * Draws linear gauge units
 *
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions} options
 */
function drawLinearUnits(context, options) {
    if (!options.units) return ;

    let {isVertical, width, length, baseX, baseY, unitsMargin} =
        context.barDimensions;
    let textHeight = options.fontUnitsSize * width / 200;
    //noinspection JSUnresolvedFunction
    let textX = round(baseX + (isVertical ? width : length) / 2);
    //noinspection JSUnresolvedFunction
    let textY = round(baseY + (isVertical ? length : width) +
        unitsMargin / 2 - textHeight / 2);

    context.save();
    context.textAlign = 'center';
    context.fillStyle = options.colorUnits;
    context.font = drawings.font(options, 'Units', width / 200);
    context.lineWidth = 0;
    context.fillText(options.units, textX, textY, isVertical ? width : length);
}

/* istanbul ignore next: private, not testable */
/**
 * Draws linear gauge needles
 *
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions} options
 */
function drawLinearBarNeedle(context, options) {
    if (!options.needle) return;

    let {isVertical, width, length, barWidth, barOffset, barMargin,
        ticksLength, X, Y, ticksPadding} = context.barDimensions;
    let hasLeft = options.needleSide !== 'right';
    let hasRight = options.needleSide !== 'left';
    let position = ticksLength *
        (drawings.normalizedValue(options).indented - options.minValue) /
        (options.maxValue - options.minValue);
    let tickWidth = (options.ticksWidth / 100 + ticksPadding) * width;
    let baseLength = (barWidth / 2 + tickWidth);
    let needleLength = baseLength * (options.needleEnd / 100);
    let sX, eX, sY, eY;
    let draw = options.needleType.toLowerCase() === 'arrow' ?
        drawLinearArrowNeedle :
        drawLinearLineNeedle;
    let barStart = (width - barWidth) / 2;
    let needleStart = baseLength * (options.needleStart / 100);
    let nLeft = barStart - tickWidth - needleStart;
    let nRight = barStart + barWidth + tickWidth + needleStart;

    context.save();

    drawings.drawNeedleShadow(context, options);

    if (isVertical) {
        //noinspection JSUnresolvedFunction
        sY = round(Y + length - barMargin - barOffset - position);

        if (hasLeft) {
            //noinspection JSUnresolvedFunction
            sX = round(X + nLeft);
            eX = sX + needleLength;
            draw(context, options, sX, sY, eX, sY, needleLength);
        }

        if (hasRight) {
            //noinspection JSUnresolvedFunction
            sX = round(X + nRight);
            eX = sX - needleLength;
            draw(context, options, sX, sY, eX, sY, needleLength, true);
        }
    }

    else {
        //noinspection JSUnresolvedFunction
        sX = round(X + barMargin + barOffset + position);

        if (hasLeft) {
            //noinspection JSUnresolvedFunction
            sY = round(Y + nLeft);
            eY = sY + needleLength;
            draw(context, options, sX, sY, sX, eY, needleLength);
        }

        if (hasRight) {
            //noinspection JSUnresolvedFunction
            sY = round(Y + nRight);
            eY = sY - needleLength;
            draw(context, options, sX, sY, sX, eY, needleLength, true);
        }
    }

    context.restore();
}

/* istanbul ignore next: private, not testable */
/**
 * Returns needle color style
 *
 * @access private
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions} options
 * @param {number} length
 * @param {boolean} [isRight]
 * @return {CanvasGradient|string}
 */
function needleStyle(context, options, length, isRight) {
    return options.colorNeedleEnd ?
        drawings.linearGradient(context,
            isRight ? options.colorNeedleEnd : options.colorNeedle,
            isRight ? options.colorNeedle : options.colorNeedleEnd,
            length,
            !context.barDimensions.isVertical
        ) : options.colorNeedle;
}

/* istanbul ignore next: private, not testable */
/**
 * Draws line needle shape
 *
 * @access private
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions} options
 * @param {number} sX
 * @param {number} sY
 * @param {number} eX
 * @param {number} eY
 * @param {number} length
 * @param {boolean} [isRight]
 */
function drawLinearLineNeedle(context, options, sX, sY, eX, eY, length,
                              isRight)
{
    context.lineWidth = options.needleWidth;
    context.strokeStyle = needleStyle(context, options, length, isRight);

    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(eX, eY);
    context.stroke();
    context.closePath();
}

/* istanbul ignore next: private, not testable */
/**
 * Draws arrow needle shape
 *
 * @access private
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions} options
 * @param {number} sX
 * @param {number} sY
 * @param {number} eX
 * @param {number} eY
 * @param {number} length
 * @param {boolean} [isRight]
 */
function drawLinearArrowNeedle(context, options, sX, sY, eX, eY, length,
                               isRight)
{
    //noinspection JSUnresolvedFunction
    let peakLength = round(length * 0.4);
    let bodyLength = length - peakLength;
    let isVertical = sX === eX;
    let halfWidth = options.needleWidth / 2;

    context.fillStyle = needleStyle(context, options, length, isRight);

    context.beginPath();

    if (isVertical) {
        if (sY > eY) bodyLength *= -1;

        context.moveTo(sX - halfWidth, sY);
        context.lineTo(sX + halfWidth, sY);
        context.lineTo(sX + halfWidth, sY + bodyLength);
        context.lineTo(sX, eY);
        context.lineTo(sX - halfWidth, sY + bodyLength);
        context.lineTo(sX - halfWidth, sY);
    }

    else {
        if (sX > eX) bodyLength *= -1;

        context.moveTo(sX, sY - halfWidth);
        context.lineTo(sX, sY + halfWidth);
        context.lineTo(sX + bodyLength, sY + halfWidth);
        context.lineTo(eX, sY);
        context.lineTo(sX + bodyLength, sY - halfWidth);
        context.lineTo(sX, sY - halfWidth);
    }

    context.fill();
    context.closePath();
}

/* istanbul ignore next: private, not testable */
/**
 * Draws value box for linear gauge
 *
 * @access private
 * @param {Canvas2DContext} context
 * @param {LinearGaugeOptions} options
 * @param {number} value
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 */
function drawLinearValueBox(context, options, value, x, y, w, h) {
    // currently value box is available only for vertical linear gauge,
    // as far as by design it is hard to find a proper place for
    // horizontal ones
    let boxWidth = (parseFloat(options.fontValueSize) || 0) * w / 200;
    let dy = (0.11 * h - boxWidth) / 2;

    context.barDimensions.isVertical &&
    drawings.drawValueBox(context, options, value, x + w / 2,
        y + h - boxWidth - dy, w);
}

/**
 * Minimalistic HTML5 Canvas Linear Gauge
 */
class LinearGauge extends BaseGauge {

    /**
     * Fired each time before gauge plate is drawn
     *
     * @event LinearGauge#beforePlate
     */

    /**
     * Fired each time before gauge highlight areas are drawn
     *
     * @event LinearGauge#beforeHighlights
     */

    /**
     * Fired each time before gauge minor ticks are drawn
     *
     * @event LinearGauge#beforeMinorTicks
     */

    /**
     * Fired each time before gauge major ticks are drawn
     *
     * @event LinearGauge#beforeMajorTicks
     */

    /**
     * Fired each time before gauge tick numbers are drawn
     *
     * @event LinearGauge#beforeNumbers
     */

    /**
     * Fired each time before gauge title is drawn
     *
     * @event LinearGauge#beforeTitle
     */

    /**
     * Fired each time before gauge units text is drawn
     *
     * @event LinearGauge#beforeUnits
     */

    /**
     * Fired each time before gauge bar area is drawn
     *
     * @event LinearGauge#beforeBar
     */

    /**
     * Fired each time before gauge progress bar is drawn
     *
     * @event LinearGauge#beforeProgressBar
     */

    /**
     * Fired each time before gauge value box is drawn
     *
     * @event LinearGauge#beforeValueBox
     */

    /**
     * Fired each time before gauge needle is drawn
     *
     * @event LinearGauge#beforeNeedle
     */

    /**
     * @constructor
     * @param {LinearGaugeOptions} options
     */
    constructor(options) {
        options = Object.assign({}, defaultLinearGaugeOptions, options || {});
        super(LinearGauge.configure(options));
    }

    /**
     * Checks and updates gauge options properly
     *
     * @param {*} options
     * @return {*}
     * @access protected
     */
    static configure(options) {
        /* istanbul ignore else */
        if (options.barStrokeWidth >= options.barWidth) {
            //noinspection JSUnresolvedFunction
            options.barStrokeWidth = round(options.barWidth / 2);
        }

        //noinspection JSUndefinedPropertyAssignment
        options.hasLeft = hasTicksBar('right', options);
        //noinspection JSUndefinedPropertyAssignment
        options.hasRight = hasTicksBar('left', options);

        if (options.value > options.maxValue) {
            options.value = options.maxValue;
        }

        if (options.value < options.minValue) {
            options.value = options.minValue;
        }

        return BaseGauge.configure(options);
    }

    /* istanbul ignore next */
    /**
     * Triggering linear gauge render on a canvas.
     *
     * @returns {LinearGauge}
     */
    draw() {
        try {
            let canvas = this.canvas;
            let [x, y, w, h] = [
                -canvas.drawX,
                -canvas.drawY,
                canvas.drawWidth,
                canvas.drawHeight
            ];
            let options = this.options;

            if (!canvas.elementClone.initialized) {
                let context = canvas.contextClone;

                // clear the cache
                context.clearRect(x, y, w, h);
                context.save();

                this.emit('beforePlate');
                this.drawBox = drawLinearPlate(context, options, x, y, w, h);

                this.emit('beforeBar');
                drawLinearBar(context, options, ...this.drawBox);

                canvas.context.barDimensions = context.barDimensions;

                this.emit('beforeHighlights');
                drawLinearBarHighlights(context, options);
                this.emit('beforeMinorTicks');
                drawLinearMinorTicks(context, options);
                this.emit('beforeMajorTicks');
                drawLinearMajorTicks(context, options);
                this.emit('beforeNumbers');
                drawLinearMajorTicksNumbers(context, options);
                this.emit('beforeTitle');
                drawLinearTitle(context, options);
                this.emit('beforeUnits');
                drawLinearUnits(context, options);

                canvas.elementClone.initialized = true;
            }

            this.canvas.commit();

            // clear the canvas
            canvas.context.clearRect(x, y, w, h);
            canvas.context.save();

            canvas.context.drawImage(canvas.elementClone, x, y, w, h);
            canvas.context.save();

            this.emit('beforeProgressBar');
            drawLinearBarProgress(canvas.context, options, ...this.drawBox);
            this.emit('beforeNeedle');
            drawLinearBarNeedle(canvas.context, options);
            this.emit('beforeValueBox');
            drawLinearValueBox(canvas.context, options, options.animatedValue ?
                this.options.value : this.value, ...this.drawBox);

            super.draw();
        }

        catch (err) {
            drawings.verifyError(err);
        }

        return this;
    }
}


/**
 * @ignore
 * @typedef {object} ns
 */
/* istanbul ignore if */
if (typeof ns !== 'undefined') {
    ns['LinearGauge'] = LinearGauge;
}

BaseGauge.initialize('LinearGauge', defaultLinearGaugeOptions);

;typeof module !== "undefined" && Object.assign(ns, {Collection: Collection,GenericOptions: GenericOptions,Animation: Animation,BaseGauge: BaseGauge,drawings: drawings,SmartCanvas: SmartCanvas,DomObserver: DomObserver,vendorize: vendorize});}(typeof module !== "undefined" ? module.exports : window));